package com.devtools.processors;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;

import com.devtools.Utils;
import com.devtools.definition.JpaColumn;
import com.devtools.definition.JpaEntity;
import com.devtools.definition.JpaRelationship;
import com.devtools.definition.Tags;

public class EntityGenerator {

    public void generate(final JpaEntity entityDef, final String outputFolder) throws IOException {
        final StringBuilder entityCode = new StringBuilder();

        // Add package declaration and imports
        generateHeaders(entityDef, entityCode);

        generateEntity(entityDef, entityCode);

        if (entityDef.getPrimaryKey() != null) {
            // Generate the @Id and @GeneratedValue annotations
            generatePrimaryKey(entityDef, entityCode);
        }

        // Add properties with @Column annotations
        generateColumns(entityDef, entityCode);

        generateAttributeOverrides(entityDef, entityCode);

        // Handle relationships (ManyToOne, OneToMany, OneToOne, ManyToMany)
        generateRelationships(entityDef, entityCode);

        // Handle Embedded fields and Embeddable classes
        generateEmbedded(entityDef, entityCode, outputFolder);

        // Handle default values
        generatePrePersist(entityDef, entityCode);

        // Close the class definition
        entityCode.append("}\n");

        Utils.writeEntity(outputFolder + File.separator + entityDef.getClassName() + ".java", entityCode);
    }

    private void generateHeaders(final JpaEntity entityDef, final StringBuilder entityCode) {
        final String timestamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
        entityCode.append("/**\n");
        entityCode.append(" * Auto-generated by hbm2Java.\n");
        entityCode.append(" * Generation date: ").append(timestamp);
        entityCode.append("\n */\n");

        entityCode.append("package ").append(entityDef.getPackageName()).append(";\n\n");

        entityCode.append("import javax.persistence.*;\n");
        entityCode.append("import java.util.*;\n");

        final Set<String> importClasses = new LinkedHashSet<>();
        if (StringUtils.isNotBlank(entityDef.getParentClass())) {
            importClasses.add(entityDef.getFullParentClass());
        }

        for (final JpaRelationship relationship : entityDef.getRelationships()) {
            // Add to imports if it's not a native type
            if (Utils.isCustomType(Utils.getSimpleClass(relationship.getTargetEntity()))) {
                importClasses.add(relationship.getTargetEntity());
            }

            getColumnImportClasses(relationship.getReferencedColumns(), importClasses);
        }

        getColumnImportClasses(entityDef.getColumns(), importClasses);

        if (!importClasses.isEmpty()) {
            entityCode.append("\n");
        }

        for (final String importClass : importClasses) {
            entityCode.append("import ").append(importClass).append(";\n");
        }
    }

    private static void getColumnImportClasses(final List<JpaColumn> columns, final Set<String> importClasses) {
        for (final JpaColumn column : columns) {
            // Add to imports if it's not a native type
            if (column.getType() != null && Utils.isCustomType(Utils.mapHibernateTypeToJava(column.getType(false)))) {
                importClasses.add(column.getType(false));
            }
            for (final Map.Entry<String, String> entry : column.getTypeParams().entrySet()) {
                if ("enumClass".equals(entry.getKey())) {
                    importClasses.add(entry.getValue());
                }
            }
        }
    }

    private void generateEntity(final JpaEntity entityDef, final StringBuilder entityCode) {
        for (final String annotation : entityDef.getAnnotations()) {
            entityCode.append("\n").append(annotation);
        }

        entityCode.append("\npublic ");
        if (entityDef.isAbstractClass()) {
            entityCode.append("abstract ");
        }
        entityCode.append("class ").append(entityDef.getClassName());

        if (StringUtils.isNotBlank(entityDef.getParentClass()) && !entityDef.isEmbeddable()) {
            entityCode.append(" extends ").append(entityDef.getParentClass());
        }
        entityCode.append(" {\n\n");
    }

    private void generatePrimaryKey(final JpaEntity entityDef, final StringBuilder entityCode) {
        for (final String annotation : entityDef.getPrimaryKey().getAnnotations()) {
            entityCode.append("    ").append(annotation).append("\n");
        }
        entityCode.append("    private ").append(entityDef.getPrimaryKey().getType())
                .append(" ").append(entityDef.getPrimaryKey().getName())
                .append(";\n\n");
    }

    private void generateColumns(final JpaEntity entityDef, final StringBuilder entityCode) {
        for (final JpaColumn col : entityDef.getColumns()) {
            if (col.isComposite()) {
                continue;
            }
            for (final String annotation : col.getAnnotations()) {
                entityCode.append("    ").append(annotation).append("\n");
            }
            entityCode.append("    private ").append(Utils.getSimpleClass(Utils.mapHibernateTypeToJava(col.getType())))
                    .append(" ").append(col.getName()).append(";\n\n");
        }
    }

    private void generateAttributeOverrides(final JpaEntity entityDef, final StringBuilder entityCode) {
        final Map<String, List<JpaColumn>> attributeOverrides = new HashMap<>();
        // First group all columns that should be treated as AttributeOverrides
        for (final JpaColumn col : entityDef.getColumns()) {
            if (!col.isComposite()) {
                continue;
            }
            final List<JpaColumn> jpaColumns;
            if (attributeOverrides.containsKey(col.getName())) {
                jpaColumns = attributeOverrides.get(col.getName());
            } else {
                jpaColumns = new ArrayList<>();
                attributeOverrides.put(col.getName(), jpaColumns);
            }
            jpaColumns.add(col);
        }

        for (final Map.Entry<String, List<JpaColumn>> entry : attributeOverrides.entrySet()) {
            entityCode.append("    // TODO check correct name for each field in the class ");
            entityCode.append(entry.getValue().get(0).getType()).append("\n");
            entityCode.append("    // TODO probably need to replace UserType class by the @Embeddable class (that must be manually adapted)\n");

            final JpaColumn varColumn = entry.getValue().get(entry.getValue().size() - 1);
            assert varColumn != null;
            for (final String annotation : varColumn.getAnnotations()) {
                entityCode.append("    ").append(annotation).append("\n");
            }
            entityCode.append("    private ").append(varColumn.getType())
                    .append(" ").append(varColumn.getName()).append(";\n\n");
        }
    }

    private void generateRelationships(final JpaEntity entityDef, final StringBuilder entityCode) {
        for (final JpaRelationship relationship : entityDef.getRelationships()) {
            if (relationship.isInverse()) {
                entityCode.append("    // TODO check correct name for 'mappedBy' in the class ");
                entityCode.append(relationship.getTargetEntity()).append("\n");
            }

            for (final String annotation : relationship.getAnnotations()) {
                entityCode.append("    ").append(annotation).append("\n");
            }

            // Add the generated relationship field
            entityCode.append("    private ");
            if (relationship.getType().equals(JpaRelationship.Type.OneToMany) ||
                    relationship.getType().equals(JpaRelationship.Type.ManyToMany)) {
                switch (relationship.getCollectionType()) {
                    case Tags.TAG_SET:
                        entityCode.append("Set<");
                        break;
                    case Tags.TAG_MAP:
                        entityCode.append("Map<");
                        break;
                    default:
                        entityCode.append("List<");
                        break;
                }
            }

            if (Tags.TAG_MAP.equals(relationship.getCollectionType())) {
                entityCode.append(relationship.getReferencedColumns().get(0).getType()).append(", ");
                entityCode.append(relationship.getTargetEntity());
            } else {
                entityCode.append(Utils.getSimpleClass(relationship.getTargetEntity()));
            }

            if (relationship.getType().equals(JpaRelationship.Type.OneToMany) ||
                    relationship.getType().equals(JpaRelationship.Type.ManyToMany)) {
                entityCode.append(">");
            }
            entityCode.append(" ").append(relationship.getName()).append(";\n\n");
        }
    }

    private void generateEmbedded(final JpaEntity entityDef, final StringBuilder entityCode, final String outputFolder)
            throws IOException {
        for (final JpaEntity embeddedField : entityDef.getEmbeddedFields()) {
            for (final String annotation : embeddedField.getAnnotations()) {
                entityCode.append("    ").append(annotation).append("\n");
            }
            entityCode.append("    private ").append(embeddedField.getClassName())
                    .append(" ").append(embeddedField.getParentClass()).append(";\n\n");

            generate(embeddedField, outputFolder);
        }
    }

    private void generatePrePersist(final JpaEntity entityDef, final StringBuilder entityCode) {
        final StringBuilder prePersistCode = new StringBuilder();

        for (final JpaColumn jpaColumn : entityDef.getColumns()) {
            if (StringUtils.isNotBlank(jpaColumn.getDefaultValue())) {
                if (prePersistCode.isEmpty()) {
                    prePersistCode.append("    @PrePersist\n");
                    prePersistCode.append("    protected void onPrePersist() {\n");
                }

                final String columnType = Utils.mapHibernateTypeToJava(jpaColumn.getType());
                prePersistCode.append("        if (this.").append(jpaColumn.getName()).append(" == null) {\n");
                prePersistCode.append("            this.").append(jpaColumn.getName()).append(" = ");
                if ("Boolean".equals(columnType)) {
                    prePersistCode.append("BooleanUtils.toBooleanObject(\"");
                } else {
                    prePersistCode.append(columnType).append(".valueOf(\"");
                }
                prePersistCode.append(jpaColumn.getDefaultValue().replace("'", "")).append("\");\n");
                prePersistCode.append("        }\n");
            }
        }

        if (!prePersistCode.isEmpty()) {
            prePersistCode.append("    }\n");
            entityCode.append(prePersistCode);
        }
    }
}
