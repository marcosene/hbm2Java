# Hibernate 4 HBM to JPA/Hibernate Annotation Mapping Guide

This guide provides a mapping from Hibernate 4 HBM XML configurations to their corresponding JPA (Jakarta Persistence API) and Hibernate-specific annotations as generated by the `hbm2java` tool. Understanding these mappings can help in migrating from legacy HBM files to modern annotation-based configurations or in understanding the output of `hbm2java`.

## Table of Contents
- Global Mappings (`<hibernate-mapping>`)
- Class Mappings (`<class>`)
- Identifier Mappings (`<id>`, `<composite-id>`)
- Property Mappings (`<property>`)
- Component Mappings (`<component>`)
- Relationship Mappings
- Collection Mappings
- Inheritance Mappings
- Query Mappings
- Other Mappings

---

## Global Mappings (`<hibernate-mapping>`)

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<hibernate-mapping default-cascade="save-update">` | (No direct equivalent at package level) | (No direct annotation) | `hbm2java` uses this to set a default cascade type (`JpaEntity.defaultCascade`) for relationships within the HBM file if they don't specify their own cascade. JPA cascades are defined per-relationship. |
| `<hibernate-mapping schema="MY_SCHEMA">` | (No direct equivalent for default schema at package level for all entities) |  | The `schema` attribute is applied to `@Table(schema = "MY_SCHEMA")` for each entity defined in this HBM, unless overridden at the class level. |
| `<hibernate-mapping catalog="MY_CATALOG">` | (No direct equivalent for default catalog at package level for all entities) |  | The `catalog` attribute is applied to `@Table(catalog = "MY_CATALOG")` for each entity defined in this HBM, unless overridden at the class level. |
| `<hibernate-mapping package="com.example.domain">` | (No direct equivalent) |  | This influences how `hbm2java` resolves unqualified class names in the HBM. Generated entities will be in this package if not fully qualified in `class name` attribute. |
| `<class name="com.example.Foo">` | `@Entity` or `@MappedSuperclass` | | The `name` attribute determines the fully qualified class name. `hbm2java` generates `@Entity`. If `abstract="true"` and no persistent fields/relationships, it might become `@MappedSuperclass`. |
| `<class name="Foo" table="FOO_TABLE">` | `@Table(name="FOO_TABLE")` |  | Maps to the database table. Applied in conjunction with `@Entity`. |
| `<class name="Foo" dynamic-update="true">` | (No direct equivalent) | `@org.hibernate.annotations.DynamicUpdate` | Optimizes SQL UPDATE statements by only including changed columns. |
| `<class name="Foo" dynamic-insert="true">` | (No direct equivalent) | `@org.hibernate.annotations.DynamicInsert` | Optimizes SQL INSERT statements by only including non-null columns. |
| `<class name="BaseFoo" abstract="true">` | `@MappedSuperclass` or `@Entity` with `abstract class` | | If the class contains persistent fields/associations, it's typically an `@Entity` and an `abstract` Java class. If it has no table and is meant for inheritance, it becomes `@MappedSuperclass`. `hbm2java` makes the Java class `abstract`. |
| `<class name="Foo" mutable="false">` | (No direct equivalent) | `@org.hibernate.annotations.Immutable` | Marks the entity as immutable (its state cannot change after creation). |

---

## Class Mappings (`<class>`)

Covers core entity definition attributes from the `<class>` tag.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Foo"> ... <cache usage="read-only"/> ... </class>` | `@Cacheable` (often implied if L2 cache is enabled) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_ONLY)` | `hbm2java` translates `<cache usage="..."/>` to Hibernate's `@Cache` annotation. JPA's `@Cacheable` is a prerequisite. `usage` maps to `CacheConcurrencyStrategy`. |
| `<class name="Foo"> ... <cache usage="read-write"/> ... </class>` | `@Cacheable` | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)` | Similar to `read-only`, but for `READ_WRITE` strategy. |
| `<class name="Foo"> ... <cache usage="nonstrict-read-write"/> ... </class>` | `@Cacheable` | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)` | For `NONSTRICT_READ_WRITE` strategy. |
| `<class name="Foo"> ... <cache usage="transactional"/> ... </class>` | `@Cacheable` | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.TRANSACTIONAL)` | For `TRANSACTIONAL` strategy. |
| `<class name="Foo" table="MAIN_FOO"> ... <join table="JOIN_FOO"> <key column="FOO_ID"/> <property name="joinedProp"/> </join> ... </class>` | `@SecondaryTable(name="JOIN_FOO", pkJoinColumns=@PrimaryKeyJoinColumn(name="FOO_ID"))` (on class) and `@Column(table="JOIN_FOO")` (on `joinedProp`) |  | `hbm2java` maps `<join>` to `@SecondaryTable`. The nested `<key column="..."/>` defines the `@PrimaryKeyJoinColumn`. Properties within `<join>` get `@Column(table="...")`. |
| `<id name="id" column="ID_COL" type="long"> <generator class="identity"/> </id>` | `@Id @Column(name="ID_COL") @GeneratedValue(strategy=GenerationType.IDENTITY)` |  | `name` is field name. `column` maps to `@Column`. `type` is Java field type. `identity` maps to `GenerationType.IDENTITY`. |
| `<id name="id" column="ID_COL" type="long"> <generator class="sequence"> <param name="sequence_name">MY_SEQ</param> </generator> </id>` | `@Id @Column(name="ID_COL") @GeneratedValue(strategy=GenerationType.SEQUENCE, generator="mySeqGen") @SequenceGenerator(name="mySeqGen", sequenceName="MY_SEQ")` |  | `sequence` maps to `GenerationType.SEQUENCE` and `@SequenceGenerator`. `sequence_name` param becomes `sequenceName`. `hbm2java` creates a generator name (e.g., "mySeqGen"). |
| `<id name="id" type="long"> <generator class="sequence"> <param name="sequence_name">MY_SEQ</param> <param name="initial_value">1</param> <param name="allocation_size">50</param> </generator> </id>` | `@Id @GeneratedValue(strategy=GenerationType.SEQUENCE, generator="mySeqGen") @SequenceGenerator(name="mySeqGen", sequenceName="MY_SEQ", initialValue=1, allocationSize=50)` |  | `initial_value` and `allocation_size` map to `initialValue` and `allocationSize` in `@SequenceGenerator`. |
| `<id name="id" type="long"> <generator class="seqhilo"> <param name="sequence">MY_SEQHILO</param> <param name="max_lo">99</param> </generator> </id>` | `@Id @GeneratedValue(generator="mySeqHiloGen")` | `@org.hibernate.annotations.GenericGenerator(name="mySeqHiloGen", strategy="seqhilo", parameters = { @org.hibernate.annotations.Parameter(name="sequence", value="MY_SEQHILO"), @org.hibernate.annotations.Parameter(name="max_lo", value="99") })` | `seqhilo` often uses `@GenericGenerator`. Params like `sequence` (for sequence name) and `max_lo` are mapped. |
| `<id name="id" column="ID_COL" type="long"> <generator class="native"/> </id>` | `@Id @Column(name="ID_COL") @GeneratedValue(strategy=GenerationType.AUTO)` |  | `native` typically maps to `GenerationType.AUTO`, letting Hibernate decide based on dialect (could be identity, sequence, or table). |
| `<id name="id" column="ID_COL" type="long"> <generator class="assigned"/> </id>` | `@Id @Column(name="ID_COL")` |  | `assigned` means the application assigns the ID, so no `@GeneratedValue`. |
| `<id name="userId" type="long"> <generator class="foreign"> <param name="property">userProfile</param> </generator> </id>` | `@Id @GeneratedValue(generator="foreignGen")` | `@org.hibernate.annotations.GenericGenerator(name="foreignGen", strategy="foreign", parameters=@org.hibernate.annotations.Parameter(name="property", value="userProfile"))` | `foreign` generator takes the ID from an associated entity (specified by `property` param). Uses `@GenericGenerator`. The field type must match the associated entity's ID type. |
| `<id name="id" type="long"> <generator class="increment"/> </id>` | `@Id @GeneratedValue(generator="incrementGen")` | `@org.hibernate.annotations.GenericGenerator(name="incrementGen", strategy="increment")` | `increment` generator is for single-node environments, Hibernate fetches max value and increments. Uses `@GenericGenerator`. Not recommended for clusters. |
| `<id name="id" type="long" unsaved-value="0L"> ... </id>` | `@Id` ... |  | JPA doesn't have a direct equivalent for `unsaved-value`. Hibernate uses it to determine if an entity is transient or detached. For generated IDs, this is less critical. `hbm2java` stores this info but it's not directly translated to an annotation for simple long types. For other types or specific scenarios, it might influence behavior. |
| `<id name="customId" type="mypackage.MyCustomIdType"> <generator class="mypackage.MyCustomGenerator"/> </id>` | `@Id @GeneratedValue(generator="customGen")` | `@org.hibernate.annotations.GenericGenerator(name="customGen", strategy="mypackage.MyCustomGenerator")` | Custom generator classes are mapped using `@GenericGenerator` with the FQCN as the strategy. The `type` attribute on `<id>` determines the field type. |

<!-- Add other main sections as placeholders similarly -->

---

## Identifier Mappings (`<id>`, `<composite-id>`)

Covers primary key mappings.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<composite-id name="compId" class="com.example.CompositeKey"> <key-property name="keyPart1" column="KP1_COL" type="string"/> <key-property name="keyPart2" column="KP2_COL" type="long"/> </composite-id>` | `@EmbeddedId @AttributeOverrides({ @AttributeOverride(name="keyPart1", column=@Column(name="KP1_COL")), @AttributeOverride(name="keyPart2", column=@Column(name="KP2_COL")) })` (if `name` attribute present on `composite-id`) |  | `hbm2java` generates an `@EmbeddedId` field named `compId` of type `com.example.CompositeKey`. `<key-property>` elements define fields within `CompositeKey` class. Column names from `<key-property>` are mapped via `@AttributeOverride` on the `@EmbeddedId` field. `type` attributes on `<key-property>` define types in `CompositeKey`. |
| `<composite-id class="com.example.CompositeKey"> <key-property name="keyPart1" column="KP1_COL"/> <key-property name="keyPart2" column="KP2_COL"/> </composite-id>` | `@IdClass(com.example.CompositeKey.class)` (on entity) and `@Id` on corresponding fields in entity that match `<key-property name="...">` and are defined in `CompositeKey`. |  | If `composite-id` has no `name` attribute, `@IdClass` is used. Entity will have separate fields (e.g., `keyPart1`, `keyPart2`) annotated with `@Id`. `CompositeKey` class defines these fields. Columns are specified on entity fields: `@Column(name="KP1_COL")`. |
| `<composite-id ...> <key-many-to-one name="user" class="com.example.User" column="USER_ID"/> </composite-id>` | Within `@EmbeddedId` class: `@ManyToOne @JoinColumn(name="USER_ID") private User user;` or for `@IdClass`: `@Id @ManyToOne @JoinColumn(name="USER_ID") private User user;` |  | `<key-many-to-one>` maps to a `@ManyToOne` association as part of the composite key. `column` attribute maps to `@JoinColumn(name=...)`. |
| `<version name="version" column="OBJ_VERSION" type="integer"/>` | `@Version @Column(name="OBJ_VERSION")` |  | Maps to a field (e.g., `private Integer version;`) annotated with `@Version` for optimistic locking. `type` dictates field type. |
| `<property name="myField" column="MY_COL" type="string" length="100"/>` | `@Column(name="MY_COL", length=100)` |  | `name` is field name. `column` and `length` map directly to `@Column` attributes. `type` determines Java field type. |
| `<property name="myField" update="false"/>` | `@Column(updatable=false)` |  | `update` maps to `updatable`. |
| `<property name="lazyField" type="blob" lazy="true"/>` | `@Basic(fetch=FetchType.LAZY) @Lob` |  | `lazy="true"` on a property maps to `@Basic(fetch=FetchType.LAZY)`. Large types like `blob`/`clob` also get `@Lob`. |
| `<property name="nonOptimisticField" optimistic-lock="false"/>` | (No direct equivalent) | `@org.hibernate.annotations.OptimisticLock(excluded=true)` | `optimistic-lock="false"` excludes the property from optimistic lock checks. |
| `<property name="multiColProp"> <column name="COL1"/> <column name="COL2"/> </property>` | (Typically for components/UserTypes) `@Columns(columns = { @Column(name="COL1"), @Column(name="COL2") })` (used with `@Type`) | `@org.hibernate.annotations.Columns(columns = { @org.hibernate.annotations.Column(name="COL1"), @org.hibernate.annotations.Column(name="COL2") })` (Hibernate's version of `@Column` for multi-column types) |  Used when a single property maps to multiple columns, often with a custom Hibernate `UserType` or an embeddable component. `hbm2java` might use this with `@Type`. |
| `<property name="status" type="org.hibernate.type.EnumType"> <type name="org.hibernate.type.EnumType"> <param name="enumClass">com.example.StatusEnum</param> <param name="useNamed">true</param> </type> </property>` | `@Enumerated(EnumType.STRING)` (if `useNamed` is true) or `@Enumerated(EnumType.ORDINAL)` (if `useNamed` is false or not present) | `@org.hibernate.annotations.Type(type = "org.hibernate.type.EnumType", parameters = { @org.hibernate.annotations.Parameter(name="enumClass", value="com.example.StatusEnum"), @org.hibernate.annotations.Parameter(name="useNamed", value="true") })` (less common if JPA `@Enumerated` suffices) | `hbm2java` attempts to map to `@Enumerated(EnumType.STRING/ORDINAL)`. If specific Hibernate type features are needed, it might use `@org.hibernate.annotations.Type` with parameters like `enumClass` and `useNamed`. |
| `<property name="customTypeField"> <type name="com.example.MyCustomUserType"> <param name="customParam">value</param> </type> </property>` |  | `@org.hibernate.annotations.Type(type = "com.example.MyCustomUserType", parameters = { @org.hibernate.annotations.Parameter(name="customParam", value="value") })` | When a specific `UserType` is defined via nested `<type>` with FQCN in `name`, it maps to Hibernate's `@Type` annotation, including any parameters. |

---

## Property Mappings (`<property>`)

Covers basic property/attribute mappings.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<component name="address" class="com.example.Address"> <property name="street" column="STREET_COL"/> <property name="city" column="CITY_COL"/> </component>` | `@Embedded private com.example.Address address;` (on entity) and `@Embeddable public class Address { @Column(name="STREET_COL") private String street; @Column(name="CITY_COL") private String city; ... }` |  | `name` is field name in owning entity. `class` is FQCN of embeddable class. Properties inside `<component>` map to fields in the embeddable class. `hbm2java` generates `@Embeddable` on the component class. Column names are defined directly on fields in embeddable class or overridden using `@AttributeOverride(s)` on the `@Embedded` field in the owner. |
| `<component name="address" class="com.example.Address"> <column-prefix>ADDR_</column-prefix> <property name="street" column="STREET"/> <property name="city" column="CITY"/> </component>` | `@Embedded @AttributeOverrides({ @AttributeOverride(name="street", column=@Column(name="ADDR_STREET")), @AttributeOverride(name="city", column=@Column(name="ADDR_CITY")) }) private com.example.Address address;` |  | `hbm2java` applies `column-prefix` to the column names of properties within the component when using `@AttributeOverride`. If `@AttributeOverride` is not used, the prefix is applied directly in the `@Column` annotations inside the embeddable class. |
| `<component name="address"> <property name="street"/> <property name="city"/> <parent name="owner"/> </component>` | `@Embedded private Address address;` (on entity). In `Address` class: `private Entity owner;` | `@org.hibernate.annotations.Parent` (on `owner` field in `Address` class) | `<parent name="owner"/>` creates a field in the component class (`Address`) that references the owning entity. `hbm2java` may annotate this with `@Parent` if it chooses to use this Hibernate-specific feature. Otherwise, it's a regular field that needs to be manually initialized by the application if bi-directional access is needed. |
| `<component name="contactInfo" class="ContactInfo"> <property name="email"/> <component name="phone" class="Phone"> <property name="number" column="PHONE_NUM"/> </component> </component>` | `@Embedded private ContactInfo contactInfo;` (on entity). In `ContactInfo` class: `@Embedded private Phone phone;`. In `Phone` class: `@Column(name="PHONE_NUM") private String number;` |  | Components can be nested. `hbm2java` creates corresponding nested `@Embedded` fields and `@Embeddable` classes. Column naming follows standard rules, potentially using `@AttributeOverride` at each level if specific names are required. |
| `<many-to-one name="user" class="com.example.User" column="USER_ID"/>` | `@ManyToOne @JoinColumn(name="USER_ID")` |  | `name` is field name. `class` is target entity type. `column` maps to `@JoinColumn(name=...)`. Default fetch is EAGER for ManyToOne. |
| `<many-to-one name="user" class="User" column="USER_ID" cascade="save-update,delete"/>` | `@ManyToOne(cascade={CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE}) @JoinColumn(name="USER_ID")` |  | `cascade` values map to `CascadeType` enum members. "all" maps to all JPA cascades. "save-update" maps to PERSIST and MERGE. |
| `<many-to-one name="user" class="User" column="USER_ID" fetch="join"/>` | `@ManyToOne(fetch=FetchType.EAGER) @JoinColumn(name="USER_ID")` |  | `fetch="join"` implies eager fetching. |
| `<many-to-one name="user" class="User" column="USER_ID" fetch="select" lazy="proxy"/>` | `@ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name="USER_ID")` |  | `fetch="select"` with `lazy="proxy"` (default for lazy) implies lazy fetching. `lazy="no-proxy"` would also be LAZY but with different Hibernate mechanics. `lazy="false"` implies EAGER. |
| `<many-to-one name="user" class="User" column="USER_ID" not-null="true" unique="true"/>` | `@ManyToOne @JoinColumn(name="USER_ID", nullable=false, unique=true)` |  | `not-null` maps to `nullable=false`. `unique` maps to `unique=true`. |
| `<many-to-one name="user" class="User" column="USER_ID" foreign-key="FK_USER_ORDER"/>` | `@ManyToOne @JoinColumn(name="USER_ID", foreignKey=@ForeignKey(name="FK_USER_ORDER"))` |  | `foreign-key` attribute specifies a custom FK constraint name. |
| `<many-to-one name="user" class="User" column="USER_ID" property-ref="userCode"/>` | `@ManyToOne @JoinColumn(name="USER_ID", referencedColumnName="userCode")` |  | `property-ref` maps the foreign key to a non-primary key column on the target entity. The referenced column must be unique. |
| `<one-to-one name="profile" class="com.example.Profile" cascade="all"/>` | `@OneToOne(cascade=CascadeType.ALL) @JoinColumn(...)` (if owning side) or `@OneToOne(mappedBy="...", cascade=CascadeType.ALL)` (if non-owning) |  | `name` and `class` as usual. `cascade` maps similarly to many-to-one. FK column handling depends on which side owns the relationship. |
| `<one-to-one name="profile" class="Profile" constrained="true"/>` | `@OneToOne @JoinColumn(name="PROFILE_ID") @MapsId` (typically, if FK is also PK) or `@OneToOne @PrimaryKeyJoinColumn` |  | `constrained="true"` means the current entity's PK is also the FK to the associated entity. This often implies a shared primary key scenario. `hbm2java` might use `@MapsId` or `@PrimaryKeyJoinColumn`. The FK column is often the same as the PK column. |
| `<one-to-one name="address" class="Address" property-ref="person"/>` | `@OneToOne(mappedBy="person")` (if `person` is the owner field in `Address`) |  | If `property-ref` refers to a property on the target entity that establishes the bidirectional link, it's often used to indicate `mappedBy` on the inverse side. `hbm2java` determines the owner based on mapping details. |

---

## Component Mappings (`<component>`)

Covers embedded object mappings.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator type="string"><column name="ANIMAL_TYPE" length="20"/></discriminator> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance. `type` on `<discriminator>` maps to `discriminatorType`. Attributes like `name` (for column name) and `length` are specified on a nested `<column>` tag within `<discriminator>` and map to `@DiscriminatorColumn`. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | | `type` on discriminator informs Hibernate about the expected type. If a formula was used, it's not a standard JPA feature and would be handled by Hibernate-specific annotations if `hbm2java` supports its conversion. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. `hbm2java` maps this by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though `hbm2java` might map them directly if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |

---

## Relationship Mappings

Covers `<many-to-one>` and `<one-to-one>` mappings.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator column="ANIMAL_TYPE" type="string" length="20"/> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance (default when `<discriminator>` is present without `<joined-subclass>` or `<union-subclass>`). `discriminator column` maps to `@DiscriminatorColumn name`. `type` maps to `discriminatorType` (STRING, CHAR, INTEGER). `length` is also set. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator formula="CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END" type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | `@org.hibernate.annotations.DiscriminatorFormula("CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END")` | If `formula` is used on `<discriminator>`, it maps to Hibernate's `@DiscriminatorFormula`. `type` on discriminator still informs Hibernate about the expected type of the formula's result. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. `hbm2java` maps this by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though `hbm2java` might map them directly if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity, or in a central place like `package-info.java`) |  | HQL query defined in CDATA section is mapped to the `query` attribute of `@NamedQuery`. `name` attribute is used for `name`. `hbm2java` typically adds these to the relevant entity class. |
| `<sql-query name="findUserWithAddress"> <return alias="user" class="com.example.User"/> <return-join alias="addr" property="user.address"/> <![CDATA[ SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ? ]]> </sql-query>` | `@NamedNativeQuery(name="findUserWithAddress", query="SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ?", resultSetMapping="userWithAddressMapping")` <br/> `@SqlResultSetMapping(name="userWithAddressMapping", entities={@EntityResult(entityClass=com.example.User.class, alias="user", fields={@FieldResult(name="address", column="addr")})})` (Note: `FieldResult` for `return-join` is simplified here; `hbm2java` might map `return-join` to a separate `@EntityResult` if `addr` is an entity, or handle it as part of the main `EntityResult`'s fields if the join is to populate a property of `user`.) |  | SQL query maps to `@NamedNativeQuery`. `<return alias="..." class="..."/>` maps to `@EntityResult(entityClass=...)`. `<return-join property="user.address"/>` (populating a property of the main return) maps to `@FieldResult` within the main `@EntityResult`. A `resultSetMapping` name is generated. If the join returns another full entity, it would be a separate `@EntityResult`. |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <return-scalar column="user_age" type="integer"/> <![CDATA[ SELECT name AS user_name, age AS user_age FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name, age AS user_age FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name", type=String.class), @ColumnResult(name="user_age", type=Integer.class)})` |  | `<return-scalar column="..." type="..."/>` maps to `@ColumnResult(name="...", type=...)` within a `@SqlResultSetMapping`. `hbm2java` derives the Java type from HBM type. |
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber" column="EMP_NO"/> <many-to-one name="department" column="DEPT_ID"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId @Column(name="EMP_NO")` <br/> On `department` field: `@NaturalId @ManyToOne @JoinColumn(name="DEPT_ID")` | `@org.hibernate.annotations.NaturalIdCache` (on class `Employee`, if `<cache>` is also used for natural-id) | Properties within `<natural-id>` are annotated with `@NaturalId`. `mutable="true"` on `<natural-id>` maps to `@NaturalId(mutable=true)` on each field. If a `<cache>` element is associated with the natural ID in HBM (not shown), `@NaturalIdCache` might be added to the entity. `hbm2java` handles this. |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied, or explicitly if needed for provider) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)` | `<cache usage="..."/>` nested within a collection tag (like `<set>`, `<list>`, etc.) maps to Hibernate's `@Cache` annotation on the collection field. `usage` maps to `CacheConcurrencyStrategy`. `region` is a separate attribute on Hibernate's `@Cache`. |

---

## Collection Mappings

Covers various collection types like `<set>`, `<list>`, `<map>`, etc., including `<one-to-many>` and `<many-to-many>` within them.

**General Collection Attributes & Concepts:**

Many attributes are common across different collection mapping tags (`<set>`, `<list>`, `<bag>`, `<map>`). These are generally translated as follows:

| HBM Attribute       | Typical JPA/Hibernate Annotation/Concept                                     | Notes                                                                                                                                                                                             |
| :------------------ | :--------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `name`              | Field name in the entity.                                                    | The name of the Java property holding the collection.                                                                                                                                             |
| `table`             | `@JoinTable(name="...")` (for ManyToMany, or OneToMany with join table), `@CollectionTable(name="...")` (for ElementCollection) | Specifies the name of the join table or collection table.                                                                                                                                         |
| `lazy`              | `fetch` attribute in `@OneToMany`, `@ManyToMany`, `@ElementCollection`.      | `lazy="true"` (default) maps to `FetchType.LAZY`. `lazy="false"` maps to `FetchType.EAGER`. `lazy="extra"` maps to `FetchType.LAZY` and enables Hibernate's "extra-lazy" behavior (e.g., `size()` doesn't load all elements). `hbm2java` may use `@LazyCollection(LazyCollectionOption.EXTRA)` for "extra". |
| `fetch`             | `@org.hibernate.annotations.Fetch(FetchMode.SELECT/JOIN/SUBSELECT)`          | `fetch="select"` (default) is standard lazy/eager loading. `fetch="join"` implies EAGER with a join. `fetch="subselect"` uses a subselect to fetch collections for multiple parent entities.         |
| `cascade`           | `cascade` attribute in `@OneToMany`, `@ManyToMany`, `@ElementCollection`.      | HBM cascade options (e.g., "all", "save-update", "delete", "delete-orphan") map to `CascadeType` values (e.g., `ALL`, `PERSIST`, `MERGE`, `REMOVE`, `DETACH`, `REFRESH`). `delete-orphan` maps to `orphanRemoval=true`. |
| `inverse="true"`    | `mappedBy="..."` attribute in `@OneToMany`, `@ManyToMany`.                     | Indicates the collection is the inverse (non-owning) side of a bidirectional relationship. The `mappedBy` value is the name of the property on the owning side.                                        |
| `order-by`          | `@OrderBy("column_name asc/desc, ...")`                                      | For collections of entities, specifies a DB-level ordering. `column_name` refers to a column in the target entity's table.                                                                       |

**The `<key>` Element:**

The `<key>` element within a collection mapping is crucial for defining the foreign key in the collection table (for `@ElementCollection` or join tables in `@ManyToMany`/`@OneToMany`) or in the child table (for `@OneToMany` without a join table) that refers back to the owning entity's primary key.

| HBM Attribute (`<key>`) | JPA Annotation(s)                                                                 | Notes                                                                                                                               |
| :---------------------- | :-------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------- |
| `column`                | `@JoinColumn(name="...")` (within `@JoinTable` or directly on collection attribute) | Specifies the foreign key column name in the collection/join table or child table.                                                       |
| `foreign-key`           | `@JoinColumn(foreignKey=@ForeignKey(name="..."))`                                 | Specifies a custom name for the foreign key constraint.                                                                             |

---
**Specific Collection Tag Mappings:**

| HBM XML Snippet (General Attributes)                                       | JPA Annotation(s) & Collection Type                                                                                                | Hibernate Annotation(s) (if needed) | Notes                                                                                                                                                                                                                                                           |
| :------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `<set name="items" table="ITEM_SET_TABLE" lazy="true" fetch="select" cascade="all" inverse="false" order-by="name asc"> <key column="OWNER_ID"/> ... </set>` | `private java.util.Set<Item> items;` <br/> `@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.LAZY)` or `@ManyToMany(...)` <br/> `@JoinTable(name="ITEM_SET_TABLE", joinColumns=@JoinColumn(name="OWNER_ID"))` (if join table used) <br/> `@OrderBy("name asc")` | `@org.hibernate.annotations.Fetch(FetchMode.SELECT)` | `hbm2java` maps `<set>` to `java.util.Set`. Attributes like `table`, `lazy`, `fetch`, `cascade`, `inverse`, `order-by` are applied as shown. `<key>` maps to `@JoinColumn`. Specific content of set (e.g. `<element>`, `<one-to-many>`) determines full mapping. |
| `<list name="tasks" table="TASK_LIST_TABLE" cascade="persist" lazy="extra"> <key column="TODO_ID"/> ... </list>` | `private java.util.List<Task> tasks;` <br/> `@OneToMany(cascade=CascadeType.PERSIST, fetch=FetchType.LAZY)` or `@ManyToMany(...)` <br/> `@JoinTable(name="TASK_LIST_TABLE", joinColumns=@JoinColumn(name="TODO_ID"))` (if join table used) <br/> `@OrderColumn` (if `<list-index>` present) | `@org.hibernate.annotations.LazyCollection(LazyCollectionOption.EXTRA)` | `hbm2java` maps `<list>` to `java.util.List`. `lazy="extra"` maps to `@LazyCollection(LazyCollectionOption.EXTRA)`. Presence of `<list-index>` (covered later) adds `@OrderColumn`. |
| `<bag name="events" lazy="false" fetch="join" access="field"> <key column="EVENT_OWNER_ID"/> ... </bag>` | `private java.util.Collection<Event> events;` <br/> `@OneToMany(fetch=FetchType.EAGER)` or `@ManyToMany(fetch=FetchType.EAGER)` <br/> `@Access(AccessType.FIELD)` | `@org.hibernate.annotations.Fetch(FetchMode.JOIN)` | `hbm2java` typically maps `<bag>` to `java.util.Collection` or `java.util.List` if no `order-by` is specified. Attributes are mapped similarly. Bags are unordered and may allow duplicates. |
| `<map name="attributes" table="ATTRIBUTES_MAP" schema="CONFIG" catalog="APP_DB" order-by="key_col desc"> <key column="ENTITY_ID"/> ... </map>` | `private java.util.Map<String, String> attributes;` <br/> `@ElementCollection` or `@OneToMany`/`@ManyToMany` <br/> `@CollectionTable(name="ATTRIBUTES_MAP", schema="CONFIG", catalog="APP_DB", joinColumns=@JoinColumn(name="ENTITY_ID"))` (for ElementCollection) <br/> `@MapKeyColumn(...)` or `@MapKeyJoinColumn(...)` or `@MapKeyEnumerated(...)` etc. (covered later) <br/> `@OrderBy("key_col desc")` |  | `hbm2java` maps `<map>` to `java.util.Map`. `table`, `schema`, `catalog` apply to `@CollectionTable` or `@JoinTable`. Key/Value mapping details (e.g. `<map-key>`, `<element>`) determine the full annotations. |

---
**Collection Element Mappings:**

This table details the mapping of elements *within* collection tags like `<set>`, `<list>`, `<bag>`, and `<map>`.

| HBM XML Snippet (Nested Element)                                                                                                | JPA Annotation(s) on Collection Field / Related Annotations                                                                                                                                                                                                                                                              | Notes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| :------------------------------------------------------------------------------------------------------------------------------ | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`<element>` (Basic Type)** <br/> `<set name="aliases"> <key column="ENTITY_ID"/> <element column="alias_name" type="string" length="50"/> </set>`                               | `java.util.Set<String> aliases;` <br/> `@ElementCollection` <br/> `@CollectionTable(name="ENTITY_ALIASES", joinColumns=@JoinColumn(name="ENTITY_ID"))` (Table name often defaults or from parent collection tag) <br/> `@Column(name="alias_name", length=50)` (Applied to the collection elements)                               | `<element>` with `type` attribute maps to a collection of basic types using `@ElementCollection`. The `@Column` annotation configures the column for these basic types in the collection table. `length`, `not-null`, etc. on `<element>` map to `@Column` attributes. If `<element>` has nested `<column name="..."/>`, that takes precedence.                                                                                                                                                                                                                                                                                          |
| **`<element>` (Embeddable Type)** <br/> `<set name="historicalAddresses"> <key column="PERSON_ID"/> <element class="com.example.AddressComponent"> <column-prefix>HIST_</column-prefix> <property name="street"/> <property name="city"/> </element> </set>` | `java.util.Set<AddressComponent> historicalAddresses;` <br/> `@ElementCollection` <br/> `@CollectionTable(name="HISTORICAL_ADDRESSES", joinColumns=@JoinColumn(name="PERSON_ID"))` <br/> `@AttributeOverrides({ @AttributeOverride(name="street", column=@Column(name="HIST_STREET")), @AttributeOverride(name="city", column=@Column(name="HIST_CITY")) })` (on `historicalAddresses` field) <br/> `// com.example.AddressComponent is @Embeddable` | If `<element class="...">` is used (or implied if collection type is an embeddable), it maps to `@ElementCollection` of an `@Embeddable` type. Properties of the embeddable are mapped to columns in the collection table. Column names can be defaulted, explicitly set in the `@Embeddable` class, or overridden by `<column-prefix>` or individual property column definitions within `<element>`, translated to `@AttributeOverride` on the `@ElementCollection` field. |
| **`<one-to-many>` (Nested)** <br/> `<set name="phones"> <key column="OWNER_ID"/> <one-to-many class="com.example.Phone"/> </set>`                                                | `java.util.Set<Phone> phones;` <br/> `@OneToMany(mappedBy="ownerFieldInPhone")` (assuming bidirectional) or `@OneToMany @JoinColumn(name="OWNER_ID")` (if unidirectional and `OWNER_ID` is in `Phone` table)                                                                                                                            | `<one-to-many>` nested in a collection tag signifies a one-to-many relationship. `class` is the target entity. `hbm2java` determines `mappedBy` if the relationship is bidirectional (by finding the corresponding `@ManyToOne` in `Phone`). If unidirectional, a `@JoinColumn` (using the `<key column="...">` from HBM) is placed on the `@OneToMany` side, implying the FK is in the target entity's table. |
| **`<many-to-many>` (Nested)** <br/> `<set name="courses" table="STUDENT_COURSES"> <key column="STUDENT_ID"/> <many-to-many class="com.example.Course" column="COURSE_ID" foreign-key="FK_COURSE_IN_JT"/> </set>` | `java.util.Set<Course> courses;` <br/> `@ManyToMany` <br/> `@JoinTable(name="STUDENT_COURSES", joinColumns=@JoinColumn(name="STUDENT_ID"), inverseJoinColumns=@JoinColumn(name="COURSE_ID", foreignKey=@ForeignKey(name="FK_COURSE_IN_JT")) )`                                                                                                  | `<many-to-many>` maps to `@ManyToMany`. `table` attribute of parent collection tag becomes `@JoinTable(name=...)`. The `<key column="..."/>` (sibling to `<many-to-many>`) defines the `joinColumns` (FK for owning entity). The `column` attribute of `<many-to-many>` defines the `inverseJoinColumns` (FK for target entity). `foreign-key` on `<many-to-many>` applies to the `inverseJoinColumns`'s FK constraint. |
| **`<list-index>` (for `<list>`)** <br/> `<list name="chapters"> <key column="BOOK_ID"/> <list-index column="chapter_num"/> <one-to-many class="Chapter"/> </list>`       | `java.util.List<Chapter> chapters;` <br/> `@OneToMany(...)` (or `@ManyToMany(...)`) <br/> `@OrderColumn(name="chapter_num")`                                                                                                                                                                                                | <!-- @org.hibernate.annotations.ListIndexBase(1) (if `base` attribute is present) -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | `<list-index>` inside a `<list>` mapping adds `@OrderColumn(name="...")` to maintain the list order in the database. The `column` attribute specifies the name of this index column. The `base` attribute (Hibernate-specific) can be used to set the starting value of the index, mapped to `@ListIndexBase`. `hbm2java` usually places this on the join table if one exists, or the target table for one-to-many. |
| **`<map-key>` (Basic Type for `<map>`)** <br/> `<map name="systemSettings" table="SETTINGS"> <key column="USER_ID"/> <map-key column="SETTING_NAME" type="string"/> <element column="SETTING_VALUE" type="string"/> </map>` | `java.util.Map<String, String> systemSettings;` <br/> `@ElementCollection` <br/> `@CollectionTable(name="SETTINGS", joinColumns=@JoinColumn(name="USER_ID"))` <br/> `@MapKeyColumn(name="SETTING_NAME")` <br/> `@Column(name="SETTING_VALUE")` (for the map values)                                                               | `<map-key>` defines the mapping for the key of a `java.util.Map` when the key is a basic type. `column` specifies the map key column name. `type` attribute maps to corresponding properties in `@MapKeyColumn` or specific annotations like `@MapKeyEnumerated` or `@MapKeyTemporal` if the type dictates. The value part of the map is defined by a subsequent `<element>`, `<one-to-many>`, etc. |
| **`<composite-map-key>` (Embeddable for `<map>`)** <br/> `<map name="customReports" table="USER_REPORTS"> <key column="USER_ID"/> <composite-map-key class="com.example.ReportKey"> <key-property name="reportName"/> <key-property name="reportVersion"/> </composite-map-key> <one-to-many class="com.example.ReportData"/> </map>` | `java.util.Map<ReportKey, ReportData> customReports;` <br/> `@OneToMany` (or `@ManyToMany`, `@ElementCollection` for values) <br/> `@MapKeyClass(ReportKey.class)` <br/> `// Column mapping for ReportKey fields done via @MapKeyColumn on those fields, or @AttributeOverrides on the collection if columns were in HBM.` | `com.example.ReportKey` must be an `@Embeddable` class. `<composite-map-key>` maps to `@MapKeyClass`. The properties of the map key embeddable (`<key-property>`) are mapped to columns in the join/collection table. `hbm2java` would typically expect these columns to be defined within the HBM for the map key or rely on defaults/overrides. The example shows the setup; actual column names for map key parts depend on how `ReportKey` is defined or if overrides are specified. |

---

## Inheritance Mappings

Covers `<subclass>`, `<joined-subclass>`, `<union-subclass>`, and `<discriminator>`.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator column="ANIMAL_TYPE" type="string" length="20"/> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance (default when `<discriminator>` is present without `<joined-subclass>` or `<union-subclass>`). `discriminator column` maps to `@DiscriminatorColumn name`. `type` maps to `discriminatorType` (STRING, CHAR, INTEGER). `length` is also set. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator formula="CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END" type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | `@org.hibernate.annotations.DiscriminatorFormula("CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END")` | If `formula` is used on `<discriminator>`, it maps to Hibernate's `@DiscriminatorFormula`. `type` on discriminator still informs Hibernate about the expected type of the formula's result. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. `hbm2java` maps this by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though `hbm2java` might map them directly if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity, or in a central place like `package-info.java`) |  | HQL query defined in CDATA section is mapped to the `query` attribute of `@NamedQuery`. `name` attribute is used for `name`. `hbm2java` typically adds these to the relevant entity class. |
| `<sql-query name="findUserWithAddress"> <return alias="user" class="com.example.User"/> <return-join alias="addr" property="user.address"/> <![CDATA[ SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ? ]]> </sql-query>` | `@NamedNativeQuery(name="findUserWithAddress", query="SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ?", resultSetMapping="userWithAddressMapping")` <br/> `@SqlResultSetMapping(name="userWithAddressMapping", entities={@EntityResult(entityClass=com.example.User.class, alias="user", fields={@FieldResult(name="address", column="addr")})})` (Note: `FieldResult` for `return-join` is simplified here; `hbm2java` might map `return-join` to a separate `@EntityResult` if `addr` is an entity, or handle it as part of the main `EntityResult`'s fields if the join is to populate a property of `user`.) |  | SQL query maps to `@NamedNativeQuery`. `<return alias="..." class="..."/>` maps to `@EntityResult(entityClass=...)`. `<return-join property="user.address"/>` (populating a property of the main return) maps to `@FieldResult` within the main `@EntityResult`. A `resultSetMapping` name is generated. If the join returns another full entity, it would be a separate `@EntityResult`. |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <return-scalar column="user_age" type="integer"/> <![CDATA[ SELECT name AS user_name, age AS user_age FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name, age AS user_age FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name", type=String.class), @ColumnResult(name="user_age", type=Integer.class)})` |  | `<return-scalar column="..." type="..."/>` maps to `@ColumnResult(name="...", type=...)` within a `@SqlResultSetMapping`. `hbm2java` derives the Java type from HBM type. |
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber" column="EMP_NO"/> <many-to-one name="department" column="DEPT_ID"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId @Column(name="EMP_NO")` <br/> On `department` field: `@NaturalId @ManyToOne @JoinColumn(name="DEPT_ID")` | `@org.hibernate.annotations.NaturalIdCache` (on class `Employee`, if `<cache>` is also used for natural-id) | Properties within `<natural-id>` are annotated with `@NaturalId`. `mutable="true"` on `<natural-id>` maps to `@NaturalId(mutable=true)` on each field. If a `<cache>` element is associated with the natural ID in HBM (not shown), `@NaturalIdCache` might be added to the entity. `hbm2java` handles this. |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write" region="itemCache"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied, or explicitly if needed for provider) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region="itemCache")` | `<cache usage="..." region="..."/>` nested within a collection tag (like `<set>`, `<list>`, etc.) maps to Hibernate's `@Cache` annotation on the collection field. `usage` maps to `CacheConcurrencyStrategy`. |
| `<class name="MyEntity" optimistic-lock="version"> ... </class>` | (Implicit default if `@Version` is present) |  | `optimistic-lock="version"` (default) implies use of a `<version>` property. `optimistic-lock="all"` would check all fields (less common). `optimistic-lock="dirty"` checks only modified fields. JPA default with `@Version` is similar to "version". `hbm2java` reflects this in generated code, but no specific annotation for "version" itself beyond `@Version` on a property. |
| `<class name="MyEntity" persister="com.example.MyPersister"> ... </class>` | (No direct equivalent) | `@org.hibernate.annotations.Persister(impl=com.example.MyPersister.class)` | `persister` attribute maps to Hibernate's `@Persister` annotation. |
| `<filter-def name="myFilter"> <filter-param name="myParam" type="string"/> </filter-def>` <br/> `<class ...> <filter name="myFilter" condition=":myParam = some_column"/> </class>` | (No direct equivalent for filter definitions. Filters are applied programmatically in JPA.) | `@org.hibernate.annotations.FilterDef(name="myFilter", parameters={@org.hibernate.annotations.ParamDef(name="myParam", type="string")})` (on a class, often package-level) <br/> `@org.hibernate.annotations.Filter(name="myFilter", condition=":myParam = some_column")` (on entity or collection) | `hbm2java` maps `<filter-def>` to `@FilterDef` (often at package level or on a common entity) and `<filter>` to `@Filter` on the specific entity/collection. |

---

## Query Mappings

Covers `<query>` and `<sql-query>`.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator column="ANIMAL_TYPE" type="string" length="20"/> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance (default when `<discriminator>` is present without `<joined-subclass>` or `<union-subclass>`). `discriminator column` maps to `@DiscriminatorColumn name`. `type` maps to `discriminatorType` (STRING, CHAR, INTEGER). `length` is also set. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator formula="CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END" type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | `@org.hibernate.annotations.DiscriminatorFormula("CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END")` | If `formula` is used on `<discriminator>`, it maps to Hibernate's `@DiscriminatorFormula`. `type` on discriminator still informs Hibernate about the expected type of the formula's result. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. `hbm2java` maps this by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though `hbm2java` might map them directly if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity, or in a central place like `package-info.java`) |  | HQL query defined in CDATA section is mapped to the `query` attribute of `@NamedQuery`. `name` attribute is used for `name`. `hbm2java` typically adds these to the relevant entity class. |
| `<sql-query name="findUserWithAddress"> <return alias="user" class="com.example.User"/> <return-join alias="addr" property="user.address"/> <![CDATA[ SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ? ]]> </sql-query>` | `@NamedNativeQuery(name="findUserWithAddress", query="SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ?", resultSetMapping="userWithAddressMapping")` <br/> `@SqlResultSetMapping(name="userWithAddressMapping", entities={@EntityResult(entityClass=com.example.User.class, alias="user", fields={@FieldResult(name="address", column="addr")})})` (Note: `FieldResult` for `return-join` is simplified here; `hbm2java` might map `return-join` to a separate `@EntityResult` if `addr` is an entity, or handle it as part of the main `EntityResult`'s fields if the join is to populate a property of `user`.) |  | SQL query maps to `@NamedNativeQuery`. `<return alias="..." class="..."/>` maps to `@EntityResult(entityClass=...)`. `<return-join property="user.address"/>` (populating a property of the main return) maps to `@FieldResult` within the main `@EntityResult`. A `resultSetMapping` name is generated. If the join returns another full entity, it would be a separate `@EntityResult`. |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <return-scalar column="user_age" type="integer"/> <![CDATA[ SELECT name AS user_name, age AS user_age FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name, age AS user_age FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name", type=String.class), @ColumnResult(name="user_age", type=Integer.class)})` |  | `<return-scalar column="..." type="..."/>` maps to `@ColumnResult(name="...", type=...)` within a `@SqlResultSetMapping`. `hbm2java` derives the Java type from HBM type. |
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber" column="EMP_NO"/> <many-to-one name="department" column="DEPT_ID"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId @Column(name="EMP_NO")` <br/> On `department` field: `@NaturalId @ManyToOne @JoinColumn(name="DEPT_ID")` | `@org.hibernate.annotations.NaturalIdCache` (on class `Employee`, if `<cache>` is also used for natural-id) | Properties within `<natural-id>` are annotated with `@NaturalId`. `mutable="true"` on `<natural-id>` maps to `@NaturalId(mutable=true)` on each field. If a `<cache>` element is associated with the natural ID in HBM (not shown), `@NaturalIdCache` might be added to the entity. `hbm2java` handles this. |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write" region="itemCache"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied, or explicitly if needed for provider) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region="itemCache")` | `<cache usage="..." region="..."/>` nested within a collection tag (like `<set>`, `<list>`, etc.) maps to Hibernate's `@Cache` annotation on the collection field. `usage` maps to `CacheConcurrencyStrategy`. |

---

## Other Mappings

Covers other tags like `<natural-id>`, `<cache>`, etc.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator column="ANIMAL_TYPE" type="string" length="20"/> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance (default when `<discriminator>` is present without `<joined-subclass>` or `<union-subclass>`). `discriminator column` maps to `@DiscriminatorColumn name`. `type` maps to `discriminatorType` (STRING, CHAR, INTEGER). `length` is also set. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator formula="CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END" type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | `@org.hibernate.annotations.DiscriminatorFormula("CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END")` | If `formula` is used on `<discriminator>`, it maps to Hibernate's `@DiscriminatorFormula`. `type` on discriminator still informs Hibernate about the expected type of the formula's result. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. `hbm2java` maps this by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though `hbm2java` might map them directly if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity, or in a central place like `package-info.java`) |  | HQL query defined in CDATA section is mapped to the `query` attribute of `@NamedQuery`. `name` attribute is used for `name`. `hbm2java` typically adds these to the relevant entity class. |
| `<sql-query name="findUserWithAddress"> <return alias="user" class="com.example.User"/> <return-join alias="addr" property="user.address"/> <![CDATA[ SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ? ]]> </sql-query>` | `@NamedNativeQuery(name="findUserWithAddress", query="SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ?", resultSetMapping="userWithAddressMapping")` <br/> `@SqlResultSetMapping(name="userWithAddressMapping", entities={@EntityResult(entityClass=com.example.User.class, alias="user", fields={@FieldResult(name="address", column="addr")})})` (Note: `FieldResult` for `return-join` is simplified here; `hbm2java` might map `return-join` to a separate `@EntityResult` if `addr` is an entity, or handle it as part of the main `EntityResult`'s fields if the join is to populate a property of `user`.) |  | SQL query maps to `@NamedNativeQuery`. `<return alias="..." class="..."/>` maps to `@EntityResult(entityClass=...)`. `<return-join property="user.address"/>` (populating a property of the main return) maps to `@FieldResult` within the main `@EntityResult`. A `resultSetMapping` name is generated. If the join returns another full entity, it would be a separate `@EntityResult`. |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <return-scalar column="user_age" type="integer"/> <![CDATA[ SELECT name AS user_name, age AS user_age FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name, age AS user_age FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name", type=String.class), @ColumnResult(name="user_age", type=Integer.class)})` |  | `<return-scalar column="..." type="..."/>` maps to `@ColumnResult(name="...", type=...)` within a `@SqlResultSetMapping`. `hbm2java` derives the Java type from HBM type. |
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber" column="EMP_NO"/> <many-to-one name="department" column="DEPT_ID"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId @Column(name="EMP_NO")` <br/> On `department` field: `@NaturalId @ManyToOne @JoinColumn(name="DEPT_ID")` | `@org.hibernate.annotations.NaturalIdCache` (on class `Employee`, if `<cache>` is also used for natural-id) | Properties within `<natural-id>` are annotated with `@NaturalId`. `mutable="true"` on `<natural-id>` maps to `@NaturalId(mutable=true)` on each field. If a `<cache>` element is associated with the natural ID in HBM (not shown), `@NaturalIdCache` might be added to the entity. `hbm2java` handles this. |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write" region="itemCache"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied, or explicitly if needed for provider) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region="itemCache")` | `<cache usage="..." region="..."/>` nested within a collection tag (like `<set>`, `<list>`, etc.) maps to Hibernate's `@Cache` annotation on the collection field. `usage` maps to `CacheConcurrencyStrategy`. |
