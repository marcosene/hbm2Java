# Hibernate 4 HBM to JPA/Hibernate Annotation Mapping Guide
This guide provides a mapping from Hibernate 4 HBM XML configurations to their corresponding JPA (Jakarta Persistence API) and Hibernate-specific annotations as generated by the `hbm2java` tool. Understanding these mappings can help in migrating from legacy HBM files to modern annotation-based configurations or in understanding the output of `hbm2java`.
## Table of Contents
- Global Mappings (`<hibernate-mapping>`)
- Class Mappings (`<class>`, `<subclass>`, `<union-subclass>`)
- Identifier Mappings (`<id>`, `<generator>`, `<param>`)
- Version Mappings (`<version>`)
- Property Mappings (`<property>`, `<column>`, `<type>`)
- Component Mappings (`<component>`, `<properties>`)
- Relationship Mappings (`<many-to-one>`, `<one-to-one>`)
- Collection Mappings (`<set>`, `<list>`, `<bag>`, `<map>`, `<key>`, `<one-to-many>`, `<many-to-many>`, `<list-index>`, `<map-key>`, `<composite-map-key>`, `<key-property>`)
- Inheritance Mappings (`<discriminator>`, `<join>`)
- Cache Mappings (`<cache>`)
- Natural ID Mappings (`<natural-id>`)
- Query Mappings (`<query>`, `<sql-query>`, `<return-scalar>`)
---
## Global Mappings (`<hibernate-mapping>`)
|HBM XML Snippet|JPA/Hibernate Annotation(s)|Notes|
|:------------------------------|:----------------------------------------------|:---------------------------------------|
| `<hibernate-mapping default-cascade="save-update">` | (No direct equivalent at package level) | The `default-cascade` attribute from the root `<hibernate-mapping>` element is used to determine the default cascade behavior for relationships if not explicitly specified on the relationship itself. <br/> JPA cascades are defined per-relationship |
---
## Class Mappings (`<class>`, `<subclass>`, `<union-subclass>`)
Covers core entity definition attributes from the `<class>`, `<subclass>`, and `<union-subclass>` tags. These HBM elements are parsed to define entity classes and their inheritance structures.
|HBM XML Snippet|JPA/Hibernate Annotation(s)|Notes|
|:------------------------------|:----------------------------------------------|:---------------------------------------|
| `<class name="com.example.Foo">` | `@Entity` |   |
| `<class name="Foo" table="FOO_TABLE">` | `@Entity` <br/> `@Table(name="FOO_TABLE")` |   |
| `<class name="Foo" dynamic-update="true">` | `@Entity`<br/>`@org.hibernate.annotations.DynamicUpdate` |   |
| `<class name="Foo" dynamic-insert="true">` | `@Entity`<br/>`@org.hibernate.annotations.DynamicInsert` |   |
| `<class name="BaseFoo" abstract="true">` | `@MappedSuperclass` or <br/> `@Entity` (if it has persistent fields/table) | `abstract="true"` typically results in `@MappedSuperclass` if the class is intended as a non-entity base. <br/> If it has a table or persistent fields, it can be an abstract `@Entity`. <br/> The generated Java class is marked abstract |
| `<class name="Foo" mutable="false">` | `@Entity`<br/>`@org.hibernate.annotations.Immutable` |   |
| `<class name="Foo" discriminator-value="F">` | `@Entity` <br/> `@DiscriminatorValue("F")` | The `discriminator-value` attribute, used in inheritance, maps to `@DiscriminatorValue` |
| `<subclass name="com.example.Bar" extends="com.example.Foo">` | `@Entity` | The `name` and `extends` attributes define the subclass relationship |
| `<subclass name="Bar" table="BAR_TABLE">` | `@Entity` <br/> `@Table(name="BAR_TABLE")` (for JOINED) | The `table` attribute for `<subclass>` is used in JOINED strategy. <br/> Ignored for SINGLE_TABLE |
| `<subclass name="Bar" discriminator-value="B">` | `@Entity` <br/> `@DiscriminatorValue("B")` |   |
| `<union-subclass name="com.example.Baz" extends="com.example.Foo">` | `@Entity` | The `name` and `extends` attributes for `<union-subclass>` define the subclass relationship |
| `<union-subclass name="Baz" table="BAZ_TABLE">` | `@Entity` <br/> `@Table(name="BAZ_TABLE")` | The `table` attribute for `<union-subclass>` specifies its dedicated table |
---
## Identifier Mappings (`<id>`, `<generator>`, `<param>`)
Covers primary key mappings. Examples are focused on `<id>`.
**Note:** Attributes like `unsaved-value` on the `<id>` tag itself, and any nested `<comment>` tags (e.g., `<column><comment>Some comment</comment></column>` within an `<id>` mapping), do not affect the generated JPA or Hibernate annotations. Their values are typically ignored during the conversion to annotations.
|HBM XML Snippet|JPA/Hibernate Annotation(s)|Notes|
|:------------------------------|:----------------------------------------------|:---------------------------------------|
| `<id name="id" type="long"/>` | `@Id` | The `name`, `type`, and `column` attributes are read from `<id>` |
| `<id name="id" column="ID_COL"/>` | `@Id` <br/> `@Column(name="ID_COL")` |   |
| `<id name="id"> <column name="ID_COL_NESTED"/> </id>` | `@Id` <br/> `@Column(name="ID_COL_NESTED")` | Its presence is checked to determine the ID's column name |
| `<id name="id" type="long"> <generator class="identity"/> </id>` | `@Id` <br/> `@GeneratedValue(strategy=GenerationType.IDENTITY)` | Common generator classes are processed to find their JPA `GenerationType` |
| `<id name="id" type="long"> <generator class="sequence"> <param name="sequence_name">MY_SEQ</param> </generator> </id>` | `@Id` <br/> `@GeneratedValue(strategy=GenerationType.SEQUENCE, generator="mySeqGen")` <br/> `@SequenceGenerator(name="mySeqGen", sequenceName="MY_SEQ")` | Nested `<param name="sequence_name">` becomes `sequenceName` in `@SequenceGenerator`. <br/> Generator parameters are read and processed |
| `<id name="id" type="long"> <generator class="native"/> </id>` | `@Id` <br/> `@GeneratedValue(strategy=GenerationType.AUTO)` |   |
| `<id name="id" type="long"> <generator class="assigned"/> </id>` | `@Id` | `generator class="assigned"` means no `@GeneratedValue` is applied |
| `<id name="id" type="mypackage.MyCustomIdType"> <generator class="mypackage.MyCustomGenerator"/> </id>` | `@Id` <br/> `@GeneratedValue(generator="customGen")`<br/>`@org.hibernate.annotations.GenericGenerator(name="customGen", strategy="mypackage.MyCustomGenerator")` | A custom generator `class` maps to `@GenericGenerator`'s strategy. <br/> If the generator class is not a known standard one, it may default to a "GENERATOR" type and include the class name as a paramete |
| `<id name="id" type="long"> <column name="ID"/> <generator class="seqhilo"> <param name="sequence">SEQ_JF</param> <param name="max_lo">100</param> <param name="parameters">START WITH 1000</param> </generator> </id>` | `@Id` <br/> `@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "generator<EntityName>")` <br/> `@Column(name = "ID")`<br/>`@org.hibernate.annotations.GenericGenerator( name = "generator<EntityName>", strategy = "org.hibernate.id.enhanced.SequenceStyleGenerator", parameters = { @org.hibernate.annotations.Parameter(name = "sequence_name", value = "SEQ_JF"), @org.hibernate.annotations.Parameter(name = "initial_value", value = "1000"), @org.hibernate.annotations.Parameter(name = "increment_size", value = "100"), @org.hibernate.annotations.Parameter(name = "optimizer", value = "hilo") } )` | `generator class="seqhilo"` maps to `@GeneratedValue(strategy=GenerationType.SEQUENCE)` and `@GenericGenerator` with `strategy="org.hibernate.id.enhanced.SequenceStyleGenerator"` and an `optimizer="hilo"` parameter. <br/> HBM <br/> HBM <br/> HBM `<param name="parameters">START WITH NNNN</param>` is parsed to extract NNNN for `@Parameter(name="initial_value")`. <br/> The `name` attribute of `@GenericGenerator` and `generator` attribute of `@GeneratedValue` are dynamically generated, typically as `"generator" + <EntityNameSimple>` (e.g., `"generatorFoo"` for entity `Foo`). <br/> The placeholder `"generator<EntityName>"` is used here for illustration. <br/> See the **Note** at the beginning of this "Identifier Mappings" section regarding `unsaved-value` and nested `<comment>` elements |
| `<id name="id" type="long"> <column name="ID"/> <generator class="foreign"> <param name="property">row</param> </generator> </id>` <br/> *Also requires a corresponding HBM `<one-to-one name="row" ... />`* | ID Field: <br/> `@Id` <br/> `@Column(name = "ID")` <br/> Related `@OneToOne` field (`row`): <br/> `@MapsId` <br/> `@JoinColumn(name = "ID")` <br/> `@OneToOne(fetch = FetchType.LAZY)`<br/>ID Field: <br/> `@org.hibernate.annotations.GenericGenerator( name = "generator<EntityName>", strategy = "foreign", parameters = @org.hibernate.annotations.Parameter(name = "property", value = "row") )` <br/>*(Note: `@GeneratedValue` is typically NOT present on the ID field itself in this strategy, as generation is delegated via `@MapsId`)* | `generator class="foreign"` with `<param name="property">field_name</param>` indicates a derived identifier. <br/> The ID is obtained from the associated `@OneToOne` relationship (`field_name`). <br/> - The `@Id` annotated field in the entity (e.g., `private Long id;`) gets the `@GenericGenerator` with `strategy="foreign"`. <br/> The `property` parameter points to the `@OneToOne` field. <br/> `@GeneratedValue` is typically not used directly on the ID field. <br/> - The corresponding `@OneToOne` field (e.g., `private com.example.CalendarRecurrencyRow row;`) is annotated with `@MapsId` (to indicate it populates the ID) and `@JoinColumn` (referring to the foreign key column which is also the PK column). <br/> - The `name` in `@GenericGenerator` is dynamically generated, typically as `"generator" + <EntityNameSimple>` (e.g., `"generatorFoo"` for entity `Foo`). <br/> The placeholder `"generator<EntityName>"` is used here for illustration. <br/> - See the **Note** at the beginning of this "Identifier Mappings" section regarding `unsaved-value` and nested `<comment>` elements. <br/> This setup implies a shared primary key scenario |
---
## Version Mappings (`<version>`)
Covers optimistic locking versioning. Version properties are typically processed by parsing their column information.
|HBM XML Snippet|JPA/Hibernate Annotation(s)|Notes|
|:------------------------------|:----------------------------------------------|:---------------------------------------|
| `<version name="version" type="integer"/>` | `@Version` |   |
| `<version name="timestamp" type="timestamp"> <column name="OBJ_VERSION"/> </version>` | `@Version` <br/> `@Column(name="OBJ_VERSION")` |   |
| `<class name="MyEntity" optimistic-lock="version"> ... </class>` | (Implicit default if `@Version` is present) | `optimistic-lock="version"` (default) implies use of a `<version>` property. <br/> `optimistic-lock="all"` would check all fields (less common). <br/> `optimistic-lock="dirty"` checks only modified fields. <br/> JPA default with `@Version` is similar to "version". <br/> `hbm2java` reflects this in generated code, but no specific annotation for "version" itself beyond `@Version` on a property |
---
## Property Mappings (`<property>`, `<column>`, `<type>`)
Covers basic property/attribute mappings.
This section also includes examples of how nested `<column>` and `<type>` elements within `<property>` are handled.
|HBM XML Snippet|JPA/Hibernate Annotation(s)|Notes|
|:------------------------------|:----------------------------------------------|:---------------------------------------|
| `<property name="myField" type="string"/>` | `@Basic` (often implied) |   |
| `<property name="myField" column="MY_COL"/>` | `@Column(name="MY_COL")` |   |
| `<property name="myField" length="100"/>` | `@Column(length=100)` |   |
| `<property name="myField" update="false"/>` | `@Column(updatable=false)` |   |
| `<property name="lazyField" lazy="true"/>` | `@Basic(fetch=FetchType.LAZY)` | `lazy="true"` on a property maps to `@Basic(fetch=FetchType.LAZY)` |
| `<property name="nonOptimisticField" optimistic-lock="false"/>` | (No direct equivalent)<br/>`@org.hibernate.annotations.OptimisticLock(excluded=true)` | `optimistic-lock="false"` excludes the property from optimistic lock checks |
| `<property name="myField"> <column name="MY_COL"/> </property>` | `@Column(name="MY_COL")` | A nested `<column>` tag can define column attributes |
| `<property name="myField"> <column name="MY_COL" length="100"/> </property>` | `@Column(name="MY_COL", length=100)` | `length` on nested `<column>` |
| `<property name="myField"> <column name="MY_COL" not-null="true"/> </property>` | `@Column(name="MY_COL", nullable=false)` |   |
| `<property name="myField"> <column name="MY_COL" unique="true"/> </property>` | `@Column(name="MY_COL", unique=true)` |   |
| `<property name="myField"> <column name="MY_COL" index="MY_IDX"/> </property>` | `@Index(name="MY_IDX")` (on `@Table` or as part of `@TableGenerator`) | The `index` attribute on a nested `<column>` maps to an `@Index` annotation. <br/> This is typically added to the `@Table` annotation of the entity or relevant join table |
| `<property name="myField"> <column name="MY_COL" default="DEFAULT_VALUE"/> </property>` | `@org.hibernate.annotations.ColumnDefault("DEFAULT_VALUE")` | The `default` attribute on a nested `<column>` maps to Hibernate's `@ColumnDefault` |
| `<property name="myField"> <column name="MY_COL" unique-key="MY_UK"/> </property>` | `@Column(name="MY_COL", unique=true)` (JPA standard unique constraint) or part of `@Table(uniqueConstraints=...)` | The `unique-key` attribute on a nested `<column>` contributes to a unique constraint, often mapped to `@Table(uniqueConstraints=@UniqueConstraint(columnNames={"MY_COL"}, name="MY_UK"))` |
| `<property name="myField"> <column name="MY_COL" sql-type="VARCHAR2(100)"/> </property>` | `@Column(name="MY_COL", columnDefinition="VARCHAR2(100)")` |   |
| `<property name="amount"> <column name="AMT" precision="10" scale="2"/> </property>` | `@Column(name="AMT", precision=10, scale=2)` |   |
| `<property name="status"> <type name="org.hibernate.type.EnumType"> <param name="enumClass">com.example.StatusEnum</param> <param name="useNamed">true</param> <param name="type">12</param> </type> </property>` | (No JPA standard annotation directly, see Hibernate Annotation)<br/>`@org.hibernate.annotations.Type(type = "org.hibernate.type.EnumType", parameters = { @org.hibernate.annotations.Parameter(name="enumClass", value="com.example.StatusEnum"), @org.hibernate.annotations.Parameter(name="useNamed", value="true"), @org.hibernate.annotations.Parameter(name="type", value="12") })` | When HBM specifies `<type name="org.hibernate.type.EnumType">`, `hbm2java` maps this to Hibernate's `@Type` annotation. <br/> It does NOT generate `@Enumerated`. <br/> Parameters like `enumClass`, `useNamed`, and `type` (for SQL type, e.g., `java.sql.Types.VARCHAR` which is 12) are mapped to the `parameters` attribute of `@Type` |
| `<property name="customTypeField"> <type name="com.example.MyCustomUserType"/> </property>` | `@org.hibernate.annotations.Type(type = "com.example.MyCustomUserType")` | When a specific `UserType` is defined via a nested `<type name="."/>`, it maps to Hibernate's `@Type`. <br/> The `name` attribute of the `<type>` tag and any nested `<param>` elements are read |
| `<property name="amount" type="com.example.VirtualCurrencyQuantityUserType"> <column name="AMOUNT_VC"/> <column name="AMOUNT_AMOUNT"/> </property>` | Conceptual JPA: <br/> `@Embedded` <br/> `@AttributeOverrides({@AttributeOverride(name="vcField", column=@Column(name="AMOUNT_VC")), @AttributeOverride(name="amountField", column=@Column(name="AMOUNT_AMOUNT"))})` <br/> `private com.example.VirtualCurrencyQuantity amount;` <br/> --- OR if UserType handles multiple columns --- <br/> `@Type(type="com.example.VirtualCurrencyQuantityUserType")` <br/> `@Columns(columns={@org.hibernate.annotations.Column(name="AMOUNT_VC"), @org.hibernate.annotations.Column(name="AMOUNT_AMOUNT")})` <br/> `private com.example.VirtualCurrencyQuantity amount;`<br/>`@org.hibernate.annotations.Columns` is Hibernate-specific. Placeholder field names "vcField", "amountField" used for `@AttributeOverride` example. | A `<property>` with multiple direct `<column>` children typically indicates mapping to a composite type. <br/> If the property's `type` refers to an `@Embeddable` class, the JPA output often uses `@Embedded` and `@AttributeOverrides` to map embeddable attributes to the specified columns. <br/> The `name` attributes in `@AttributeOverride` must match field names within the embeddable class. <br/> If the `type` is a Hibernate UserType that handles multiple columns, Hibernate's `@Type` annotation along with `@Columns` would be used |
---
## Component Mappings (`<component>`, `<properties>`)
Covers embedded object mappings using `<component>`. The `<properties>` tag is for grouping properties, often within a component or a named property group.
|HBM XML Snippet|JPA/Hibernate Annotation(s)|Notes|
|:------------------------------|:----------------------------------------------|:---------------------------------------|
| `<component name="address" class="com.example.Address"> <property name="street"/> </component>` | `@Embedded` <br/> `private com.example.Address address;` <br/> --- <br/> `@Embeddable` <br/> `public class Address { private String street; ... }` |   |
| `<class name="User"> ... <properties name="nameDetails" unique="true"> <property name="firstName"/> <property name="lastName"/> </properties> </class>` | If `nameDetails` implies a new Embeddable: <br/> `@Embedded private NameDetails nameDetails;` <br/> --- <br/> `@Embeddable public class NameDetails { ... @Column(unique=true) private String firstName; ...}` <br/> OR (if unique constraint on owning table): <br/> `@Table(uniqueConstraints=@UniqueConstraint(name="nameDetails_UK", columnNames={"firstName_col", "lastName_col"}))` | The `name` and `unique` attributes are read from `<properties>`. <br/> If `unique="true"`, this `name` is used to form a unique constraint name for properties parsed within. <br/> A separate `@Embeddable` class might be generated for the properties group, or they might be mapped directly on the entity, applying uniqueness as feasible |
---
## Relationship Mappings (`<many-to-one>`, `<one-to-one>`)
Covers `<many-to-one>` and `<one-to-one>` mappings.
|HBM XML Snippet|JPA/Hibernate Annotation(s)|Notes|
|:------------------------------|:----------------------------------------------|:---------------------------------------|
| `<many-to-one name="user" class="com.example.User"/>` | `@ManyToOne` | The default fetch strategy for relationships is often "eager". <br/> Since `FetchType.EAGER` is the JPA default for `@ManyToOne`, the `fetch=FetchType.EAGER` attribute is often omitted in the final generated JPA code if the HBM implies eager fetching |
| `<many-to-one name="user" column="USER_ID"/>` | `@ManyToOne` <br/> `@JoinColumn(name="USER_ID")` |   |
| `<many-to-one name="user" cascade="save-update,delete"/>` | `@ManyToOne(cascade={CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE})` | `cascade` values are processed according to their HBM to JPA `CascadeType` mappings. <br/> For example, "save-update" maps to `CascadeType.PERSIST` and `CascadeType.MERGE` |
| `<many-to-one name="user" fetch="join"/>` | `@ManyToOne(fetch=FetchType.EAGER)` | `fetch="join"` explicitly sets EAGER fetching. <br/> This attribute is read, resulting in `fetch=FetchType.EAGER` in JPA |
| `<many-to-one name="user" fetch="select"/>` | `@ManyToOne(fetch=FetchType.LAZY)` | The `fetch="select"` attribute is read. <br/> For `@ManyToOne`, this implies LAZY fetching unless `lazy="false"` is also present. <br/> Since JPA's default for `@ManyToOne` is EAGER, `fetch=FetchType.LAZY` will be generated if the HBM indicates lazy fetching |
| `<many-to-one name="user" lazy="proxy"/>` | `@ManyToOne(fetch=FetchType.LAZY)` | `lazy="proxy"` (or `lazy="true"`) implies LAZY fetching. <br/> This is processed and generates `fetch=FetchType.LAZY` in JPA, as it overrides the JPA default (EAGER for `@ManyToOne`) |
| `<many-to-one name="user" lazy="false"/>` | `@ManyToOne` | `lazy="false"` implies EAGER fetching. <br/> As this is the JPA default for `@ManyToOne`, the `fetch=FetchType.EAGER` attribute is often omitted in generated JPA |
| `<many-to-one name="user" not-null="true"/>` | `@ManyToOne` <br/> `@JoinColumn(nullable=false)` |   |
| `<many-to-one name="user" unique="true"/>` | `@ManyToOne` <br/> `@JoinColumn(unique=true)` |   |
| `<many-to-one name="user" foreign-key="FK_USER_ORDER"/>` | `@ManyToOne` <br/> `@JoinColumn(foreignKey=@ForeignKey(name="FK_USER_ORDER"))` |   |
| `<many-to-one name="user" property-ref="userCode"/>` | `@ManyToOne` <br/> `@JoinColumn(referencedColumnName="userCode")` | The `property-ref` attribute maps the foreign key to a non-primary-key column on the target entity. <br/> This referenced column must be unique |
| `<many-to-one name="user" access="field"/>` | `@ManyToOne` <br/> `@Access(AccessType.FIELD)` |   |
| `<many-to-one name="user" index="IDX_USER"/>` | `@ManyToOne` <br/> `@JoinColumn(name="USER_ID")` (index applied via `@Table`) | The `index` attribute on `many-to-one` suggests an index on the foreign key column. <br/> This is typically achieved by adding an `@Index` annotation to the `@Table` definition for the column specified in `@JoinColumn` |
| `<one-to-one name="profile" class="com.example.Profile"/>` | `@OneToOne` |   |
| `<one-to-one name="profile" cascade="all"/>` | `@OneToOne(cascade=CascadeType.ALL)` | `cascade` maps similarly to many-to-one relationships |
| `<one-to-one name="profile" constrained="true"/>` | `@OneToOne(optional=false)` <br/> `@MapsId` (common for shared PK) <br/> (The foreign key column is also the primary key column) | `constrained="true"` (meaning the relationship is mandatory and typically implies a shared primary key) maps to `@OneToOne(optional=false)`. <br/> If the entity's ID is derived from this relationship, `@MapsId` is used. <br/> In a shared PK scenario, the join column for the relationship also serves as the primary key |
| `<one-to-one name="address" property-ref="person"/>` | `@OneToOne(mappedBy="person")` (if `person` is owner field in `Address`) or <br/> `@JoinColumn(referencedColumnName="person")` (if this side is owner and FK refers to non-PK 'person' field in Address) | If `property-ref` indicates the `mappedBy` property on the target side of the relationship, then `mappedBy` is used. <br/> If it refers to a non-primary-key column on the target for joining, `referencedColumnName` in `@JoinColumn` is used |
---
## Collection Mappings (`<set>`, `<list>`, `<bag>`, `<map>`, `<key>`, `<one-to-many>`, `<many-to-many>`, `<list-index>`, `<map-key>`, `<composite-map-key>`, `<key-property>`)
Covers various collection types and their specific elements.
**General Collection Attributes & Concepts:**
|HBM Attribute|Typical JPA/Hibernate Annotation/Concept|Notes|
|:------------------|:---------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `name` | Field name in the entity. | The name of the Java property holding the collection. |
| `table` | `@JoinTable(name="...")` (for ManyToMany, or OneToMany with join table) | Specifies the name of the join table. This attribute is read when parsing collection mappings that involve entity relationships (e.g., `<many-to-many>`, or `<one-to-many>` using a join table). |
| `lazy` | `fetch` attribute in `@OneToMany`, `@ManyToMany`. | HBM's default for collections is `lazy="true"`. `lazy="true"` maps to `FetchType.LAZY`. `lazy="false"` maps to `FetchType.EAGER`. `lazy="extra"` maps to `FetchType.LAZY` and may enable Hibernate's "extra-lazy" behavior (e.g., `size()` doesn't load all elements); Hibernate's `@LazyCollection(LazyCollectionOption.EXTRA)` might be used for "extra". If `lazy="true"` (or omitted) in HBM, the generated JPA `fetch=FetchType.LAZY` attribute is often omitted as it's the default. |
| `fetch` | `fetch` attribute in `@OneToMany`, `@ManyToMany` (e.g., `FetchType.EAGER`, `FetchType.LAZY`) <br/> @org.hibernate.annotations.Fetch(FetchMode.SELECT/JOIN/SUBSELECT) | The HBM fetch attribute influences the FetchType on the JPA relationship annotation and/or Hibernate's @Fetch. <br/> - fetch="join" maps to FetchType.EAGER (often with @Fetch(FetchMode.JOIN)). <br/> - fetch="select" (HBM default for collections if lazy="true") maps to FetchType.LAZY (often with @Fetch(FetchMode.SELECT)). <br/> - fetch="subselect" uses a subselect to fetch collections for multiple parent entities (often with @Fetch(FetchMode.SUBSELECT)). <br/> If the HBM fetch strategy (combined with lazy) results in a JPA default (e.g., FetchType.LAZY for @OneToMany), the explicit fetch attribute might be omitted in the generated JPA. |
| `cascade` | `cascade` attribute in `@OneToMany`, `@ManyToMany`. | HBM cascade options (e.g., "all", "save-update", "delete", "delete-orphan") map to CascadeType values (e.g., ALL, PERSIST, MERGE, REMOVE, DETACH, REFRESH). "delete-orphan" maps to orphanRemoval=true. |
| `inverse="true"` | `mappedBy="..."` attribute in `@OneToMany`, `@ManyToMany`. | Indicates the collection is the inverse (non-owning) side of a bidirectional relationship. The `mappedBy` value is the name of the property on the owning side. |
| `order-by` | `@OrderBy("column_name asc/desc, ...")` | For collections of entities, specifies a DB-level ordering. `column_name` refers to a column in the target entity's table. |
**The `<key>` Element:**
|HBM Attribute (`<key>`)|JPA Annotation(s)|Notes|
|:----------------------|:--------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------------------------------------------------|
| `column` | `@JoinColumn(name="...")` (within `@JoinTable` or directly on collection attribute) | Specifies the foreign key column name in the collection/join table or child table. |
| `foreign-key` | `@JoinColumn(foreignKey=@ForeignKey(name="..."))` | Specifies a custom name for the foreign key constraint. |
---
**Specific Collection Tag Mappings:**
|HBM XML Snippet (General Attributes)|JPA Annotation(s) & Collection Type|Hibernate Annotation(s) (if needed)|Notes|
|:-------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------|:----------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `<set name="items" table="ITEM_SET_TABLE" lazy="true" fetch="select" cascade="all" inverse="false" order-by="name asc"> <key column="OWNER_ID"/> ... </set>` | `private java.util.Set<Item> items;` <br/> `@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.LAZY)` or `@ManyToMany(...)` <br/> `@JoinTable(name="ITEM_SET_TABLE", joinColumns=@JoinColumn(name="OWNER_ID"))` (if join table used) <br/> `@OrderBy("name asc")` | @org.hibernate.annotations.Fetch(FetchMode.SELECT) | `hbm2java` maps `<set>` to `java.util.Set`. Attributes like `table`, `lazy`, `fetch`, `cascade`, `inverse`, `order-by` are applied as shown. `<key>` maps to `@JoinColumn`. HBM `fetch="select"` (often with `lazy="true"`) results in `FetchType.LAZY`. Specific content of set (e.g. `<one-to-many>`) determines full mapping. HBM fetch="select" contributes to FetchType.LAZY. |
| `<list name="tasks" table="TASK_LIST_TABLE" cascade="persist" lazy="extra"> <key column="TODO_ID"/> ... </list>` | `private java.util.List<Task> tasks;` <br/> `@OneToMany(cascade=CascadeType.PERSIST, fetch=FetchType.LAZY)` or `@ManyToMany(...)` <br/> `@JoinTable(name="TASK_LIST_TABLE", joinColumns=@JoinColumn(name="TODO_ID"))` (if join table used) <br/> `@OrderColumn` (if `<list-index>` present) | @org.hibernate.annotations.LazyCollection(LazyCollectionOption.EXTRA) | `hbm2java` maps `<list>` to `java.util.List`. `lazy="extra"` results in `FetchType.LAZY` as the specific Hibernate `@LazyCollection` annotation is not generated by the tool. Presence of `<list-index>` (covered later) adds `@OrderColumn`. Specific content (e.g. `<one-to-many>`) determines full mapping. lazy="extra" maps to @LazyCollection(LazyCollectionOption.EXTRA). |
| `<bag name="events" lazy="false" fetch="join" access="field"> <key column="EVENT_OWNER_ID"/> ... </bag>` | `private java.util.Collection<Event> events;` <br/> `@OneToMany(fetch=FetchType.EAGER)` or `@ManyToMany(fetch=FetchType.EAGER)` <br/> `@Access(AccessType.FIELD)` | @org.hibernate.annotations.Fetch(FetchMode.JOIN) | `hbm2java` typically maps `<bag>` to `java.util.Collection` or `java.util.List` if no `order-by` is specified. HBM `fetch="join"` results in `FetchType.EAGER`. Attributes are mapped similarly. Bags are unordered and may allow duplicates. Specific content (e.g. `<one-to-many>`) determines full mapping. HBM fetch="join" results in FetchType.EAGER. |
| `<map name="attributes" table="ATTRIBUTES_MAP" order-by="key_col desc"> <key column="ENTITY_ID"/> <map-key column="ATTR_NAME" type="string"/> <one-to-many class="com.example.MapValueEntity"/> </map>` | `private java.util.Map<String, com.example.MapValueEntity> attributes;` <br/> `@OneToMany` <br/> `@JoinTable(name="ATTRIBUTES_MAP", joinColumns=@JoinColumn(name="ENTITY_ID"))` <br/> `@MapKeyColumn(name="ATTR_NAME")` <br/> `@OrderBy("key_col desc")` |   | A `<map>` element maps to `java.util.Map`. Attributes `name`, `table`, and `order-by` are translated. The `schema` and `catalog` attributes on HBM `<map>` are not implemented for annotation generation. Key mapping is via `<map-key>` (to `@MapKeyColumn`) or `<map-key-many-to-many>`. Value mapping for entity types is via `<one-to-many>` or `<many-to-many>`. The schema and catalog attributes on HBM <map> are not implemented for annotation generation. |
---
## Inheritance Mappings
Covers inheritance strategies. `<subclass>` and `<union-subclass>` are primarily handled in the "Class Mappings" section. This section focuses on elements that define the inheritance strategy itself (`<discriminator>`) and additional tables for joined inheritance (`<join>`).
|HBM XML Snippet|JPA/Hibernate Annotation(s)|Notes|
|:------------------------------|:----------------------------------------------|:---------------------------------------|
| `<class name="Animal"> <id name="id"/> <discriminator type="string"/> ... </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` <br/> `@DiscriminatorColumn(discriminatorType=DiscriminatorType.STRING)` | For `SINGLE_TABLE` inheritance. <br/> The `type` attribute of `<discriminator>` is read. <br/> If a nested `<column>` is not present, the discriminator column name defaults to "DTYPE" and length is not set |
| `<class name="Animal"> <id name="id"/> <discriminator type="integer"> <column name="ANIMAL_TYPE" length="4"/> </discriminator> ... </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` <br/> `@DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.INTEGER, length=4)` | The `type` attribute on `<discriminator>` maps to `discriminatorType`. <br/> The `name` and `length` attributes from a nested `<column>` tag are read for the discriminator column |
| `<class name="Foo" table="MAIN_FOO"> ... <join table="JOIN_FOO"> <key column="FOO_ID"/> <property name="joinedProp"/> </join> ... </class>` | `@SecondaryTable(name="JOIN_FOO", pkJoinColumns=@PrimaryKeyJoinColumn(name="FOO_ID"))` (on class `Foo`) <br/> `@Column(table="JOIN_FOO")` (on `joinedProp` field) | The `<join>` tag is handled during entity parsing. <br/> The `table` attribute of `<join>` specifies the secondary table name. <br/> The nested `<key column="."/>` defines the `@PrimaryKeyJoinColumn` used within the `pkJoinColumns` attribute of `@SecondaryTable`. <br/> Properties within the `<join>` block are mapped to this secondary table |
|`<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator type="string"><column name="ANIMAL_TYPE" length="20"/></discriminator> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>`|On Animal (superclass): @Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20) <br/> On Dog (subclass): @Entity @DiscriminatorValue("DOG") <br/> On Cat (subclass): @Entity @DiscriminatorValue("CAT")|For SINGLE_TABLE inheritance. <br/> The type attribute on <discriminator> maps to discriminatorType. <br/> Attributes like name (for column name) and length are specified on a nested <column> tag within <discriminator> and map to @DiscriminatorColumn. <br/> Each <subclass name="." discriminator-value="."/> becomes an @Entity extending the superclass and gets a @DiscriminatorValue|
|`<class name="Payment"> <id name="id"/> <discriminator type="string"/> ... </class>`|On Payment (superclass): @Inheritance(strategy=InheritanceType.SINGLE_TABLE)|The type attribute on the discriminator informs Hibernate about the expected type. <br/> If a formula was used, it's not a standard JPA feature and would be handled by Hibernate-specific annotations if the conversion process supports it|
|`<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>`|On Gadget (superclass): @Inheritance(strategy=InheritanceType.TABLE_PER_CLASS) <br/> On Phone (subclass): @Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id")) (if id column name is same as root) <br/> On Camera (subclass): @Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))|For TABLE_PER_CLASS strategy. <br/> Each <union-subclass name="." table="."/> becomes an @Entity with its own @Table. <br/> This is mapped by setting @Inheritance(strategy=InheritanceType.TABLE_PER_CLASS) on the root entity. <br/> Subclasses might need @AttributeOverride for inherited properties if column names need to be specified per subclass table, though direct mapping might occur if column names are consistent or defined in HBM. <br/> IDs are usually duplicated in each table|
---
## Cache Mappings (`<cache>`)
Covers entity and collection caching.
|HBM XML Snippet|JPA/Hibernate Annotation(s)|Notes|
|:------------------------------|:----------------------------------------------|:---------------------------------------|
| `<class name="Foo"> <cache usage="read-only"/> ... </class>` | `@Cacheable` (often implied by JPA provider if L2 cache enabled)<br/>`@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_ONLY)` | The `region` attribute is  for standard JPA caching annotations |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write" region="itemCache"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied)<br/>`@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region="itemCache")` | The `region` attribute is also mapped. <br/> <cache usage="." region="."/> nested within a collection tag maps to Hibernate's @Cache annotation on the collection field. <br/> `usage` maps to `CacheConcurrencyStrategy`. |
---
## Natural ID Mappings (`<natural-id>`)
Covers mapping of natural business keys. Natural ID properties are parsed accordingly.
|HBM XML Snippet|JPA/Hibernate Annotation(s)|Notes|
|:------------------------------|:----------------------------------------------|:---------------------------------------|
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber" column="EMP_NO"/> <many-to-one name="department" column="DEPT_ID"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId @Column(name="EMP_NO")` <br/> On `department` field: `@NaturalId @ManyToOne @JoinColumn(name="DEPT_ID")`<br/>`@org.hibernate.annotations.NaturalIdCache` (on class `Employee`, if `<cache>` is also used for `natural-id`) | Properties within `<natural-id>` are annotated with `@NaturalId`. <br/> `mutable="true"` on `<natural-id>` maps to `@NaturalId(mutable=true)` on each field (ensure this applies to both property and many-to-one). <br/> If a `<cache>` element is associated with the natural ID in HBM (not shown), `@NaturalIdCache` might be added to the entity. <br/> `hbm2java` handles this. <br/> Nested `<property>` and `<many-to-one>` elements are parsed to become part of the natural ID. |
---
## Query Mappings (`<query>`, `<sql-query>`, `<return-scalar>`)
Covers named HQL and SQL queries. Query definitions and their return types are parsed.
|HBM XML Snippet|JPA/Hibernate Annotation(s)|Notes|
|:------------------------------|:----------------------------------------------|:---------------------------------------|
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity or in `package-info.java`) |   |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <return-scalar column="user_age" type="integer"/> <![CDATA[ SELECT name AS user_name, age AS user_age FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name, age AS user_age FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name", type=String.class), @ColumnResult(name="user_age", type=Integer.class)})` | Nested `<return-scalar>` elements are processed, reading their `column` and `type` attributes. <br/> The `type` on `@ColumnResult` can be set based on the HBM type |
---
