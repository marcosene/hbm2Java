# Hibernate 4 HBM to JPA/Hibernate Annotation Mapping Guide

This guide provides a mapping from Hibernate 4 HBM XML configurations to their corresponding JPA (Jakarta Persistence API) and Hibernate-specific annotations as generated by the `hbm2java` tool. Understanding these mappings can help in migrating from legacy HBM files to modern annotation-based configurations or in understanding the output of `hbm2java`.

## Table of Contents
- Global Mappings (`<hibernate-mapping>`)
- Class Mappings (`<class>`, `<subclass>`, `<union-subclass>`)
- Identifier Mappings (`<id>`, `<generator>`, `<param>`)
- Version Mappings (`<version>`)
- Property Mappings (`<property>`, `<column>`, `<type>`)
- Component Mappings (`<component>`, `<properties>`)
- Relationship Mappings (`<many-to-one>`, `<one-to-one>`)
- Collection Mappings (`<set>`, `<list>`, `<bag>`, `<map>`, `<key>`, `<one-to-many>`, `<many-to-many>`, `<list-index>`, `<map-key>`, `<composite-map-key>`, `<key-property>`)
- Inheritance Mappings (`<discriminator>`, `<join>`)
- Cache Mappings (`<cache>`)
- Natural ID Mappings (`<natural-id>`)
- Query Mappings (`<query>`, `<sql-query>`, `<return-scalar>`)

---

## Global Mappings (`<hibernate-mapping>`)

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<hibernate-mapping default-cascade="save-update">` | (No direct equivalent at package level) | (No direct annotation) | The `default-cascade` attribute from the root `<hibernate-mapping>` element is used to determine the default cascade behavior for relationships if not explicitly specified on the relationship itself. JPA cascades are defined per-relationship. |
<!-- schema, catalog, package attributes for hibernate-mapping are not typically processed for direct annotation generation. -->

---

## Class Mappings (`<class>`, `<subclass>`, `<union-subclass>`)

Covers core entity definition attributes from the `<class>`, `<subclass>`, and `<union-subclass>` tags. These HBM elements are parsed to define entity classes and their inheritance structures.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="com.example.Foo">` | `@Entity` | | The `name` attribute determines the Fully Qualified Class Name (FQCN). |
| `<class name="Foo" table="FOO_TABLE">` | `@Entity` <br/> `@Table(name="FOO_TABLE")` |  | The `table` attribute maps to `@Table(name=...)`. |
| `<class name="Foo" dynamic-update="true">` | `@Entity` | `@org.hibernate.annotations.DynamicUpdate` | The `dynamic-update` attribute maps to `@DynamicUpdate`. |
| `<class name="Foo" dynamic-insert="true">` | `@Entity` | `@org.hibernate.annotations.DynamicInsert` | The `dynamic-insert` attribute maps to `@DynamicInsert`. |
| `<class name="BaseFoo" abstract="true">` | `@MappedSuperclass` or <br/> `@Entity` (if it has persistent fields/table) | | `abstract="true"` typically results in `@MappedSuperclass` if the class is intended as a non-entity base. If it has a table or persistent fields, it can be an abstract `@Entity`. The generated Java class is marked abstract. |
| `<class name="Foo" mutable="false">` | `@Entity` | `@org.hibernate.annotations.Immutable` | The `mutable="false"` attribute maps to `@Immutable`. |
| `<class name="Foo" discriminator-value="F">` | `@Entity` <br/> `@DiscriminatorValue("F")` | | The `discriminator-value` attribute, used in inheritance, maps to `@DiscriminatorValue`. |
| `<subclass name="com.example.Bar" extends="com.example.Foo">` | `@Entity` | | The `name` and `extends` attributes define the subclass relationship. |
| `<subclass name="Bar" table="BAR_TABLE">` | `@Entity` <br/> `@Table(name="BAR_TABLE")` (for JOINED) | | The `table` attribute for `<subclass>` is used in JOINED strategy. Ignored for SINGLE_TABLE. |
| `<subclass name="Bar" discriminator-value="B">` | `@Entity` <br/> `@DiscriminatorValue("B")` | | The `discriminator-value` for `<subclass>` maps to `@DiscriminatorValue`. |
| `<union-subclass name="com.example.Baz" extends="com.example.Foo">` | `@Entity` | | The `name` and `extends` attributes for `<union-subclass>` define the subclass relationship. |
| `<union-subclass name="Baz" table="BAZ_TABLE">` | `@Entity` <br/> `@Table(name="BAZ_TABLE")` | | The `table` attribute for `<union-subclass>` specifies its dedicated table. |
<!-- Other attributes like 'schema', 'catalog', 'proxy', 'lazy', 'batch-size', 'select-before-update', 'optimistic-lock' for <class> are not typically processed for direct annotation generation relevant to core entity model construction. -->

---

## Identifier Mappings (`<id>`, `<generator>`, `<param>`)

Covers primary key mappings. `<composite-id>` is not listed as implemented, so examples are focused on `<id>`.

**Note:** Attributes like `unsaved-value` on the `<id>` tag itself, and any nested `<comment>` tags (e.g., `<column><comment>Some comment</comment></column>` within an `<id>` mapping), do not affect the generated JPA or Hibernate annotations. Their values are typically ignored during the conversion to annotations.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<id name="id" type="long"/>` | `@Id` |  | The `name` attribute becomes the field name. The `type` attribute determines the Java field type (often mapped via utility functions). The `name`, `type`, and `column` attributes are read from `<id>`. |
| `<id name="id" column="ID_COL"/>` | `@Id` <br/> `@Column(name="ID_COL")` |  | The `column` attribute on `<id>` maps to `@Column(name=...)`. |
| `<id name="id"> <column name="ID_COL_NESTED"/> </id>` | `@Id` <br/> `@Column(name="ID_COL_NESTED")` | | A nested `<column>` tag within `<id>` also defines the column name. Its presence is checked to determine the ID's column name. |
| `<id name="id" type="long"> <generator class="identity"/> </id>` | `@Id` <br/> `@GeneratedValue(strategy=GenerationType.IDENTITY)` |  | `generator class="identity"` maps to `GenerationType.IDENTITY`. Common generator classes are processed to find their JPA `GenerationType`. |
| `<id name="id" type="long"> <generator class="sequence"> <param name="sequence_name">MY_SEQ</param> </generator> </id>` | `@Id` <br/> `@GeneratedValue(strategy=GenerationType.SEQUENCE, generator="mySeqGen")` <br/> `@SequenceGenerator(name="mySeqGen", sequenceName="MY_SEQ")` |  | `generator class="sequence"` maps to `GenerationType.SEQUENCE`. Nested `<param name="sequence_name">` becomes `sequenceName` in `@SequenceGenerator`. Generator parameters are read and processed. |
| `<id name="id" type="long"> <generator class="native"/> </id>` | `@Id` <br/> `@GeneratedValue(strategy=GenerationType.AUTO)` |  | `generator class="native"` maps to `GenerationType.AUTO`. |
| `<id name="id" type="long"> <generator class="assigned"/> </id>` | `@Id` |  | `generator class="assigned"` means no `@GeneratedValue` is applied. |
| `<id name="id" type="mypackage.MyCustomIdType"> <generator class="mypackage.MyCustomGenerator"/> </id>` | `@Id` <br/> `@GeneratedValue(generator="customGen")` | `@org.hibernate.annotations.GenericGenerator(name="customGen", strategy="mypackage.MyCustomGenerator")` | A custom generator `class` maps to `@GenericGenerator`'s strategy. If the generator class is not a known standard one, it may default to a "GENERATOR" type and include the class name as a parameter. |
| `<id name="id" type="long"> <column name="ID"/> <generator class="seqhilo"> <param name="sequence">SEQ_JF</param> <param name="max_lo">100</param> <param name="parameters">START WITH 1000</param> </generator> </id>` | `@Id` <br/> `@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "generator<EntityName>")` <br/> `@Column(name = "ID")` | `@org.hibernate.annotations.GenericGenerator( name = "generator<EntityName>", strategy = "org.hibernate.id.enhanced.SequenceStyleGenerator", parameters = { @org.hibernate.annotations.Parameter(name = "sequence_name", value = "SEQ_JF"), @org.hibernate.annotations.Parameter(name = "initial_value", value = "1000"), @org.hibernate.annotations.Parameter(name = "increment_size", value = "100"), @org.hibernate.annotations.Parameter(name = "optimizer", value = "hilo") } )` | `generator class="seqhilo"` maps to `@GeneratedValue(strategy=GenerationType.SEQUENCE)` and `@GenericGenerator` with `strategy="org.hibernate.id.enhanced.SequenceStyleGenerator"` and an `optimizer="hilo"` parameter. <br/> HBM `<param name="sequence">` maps to `@Parameter(name="sequence_name")`. <br/> HBM `<param name="max_lo">` maps to `@Parameter(name="increment_size")`. <br/> HBM `<param name="parameters">START WITH NNNN</param>` is parsed to extract NNNN for `@Parameter(name="initial_value")`. <br/> The `name` attribute of `@GenericGenerator` and `generator` attribute of `@GeneratedValue` are dynamically generated, typically as `"generator" + <EntityNameSimple>` (e.g., `"generatorFoo"` for entity `Foo`). The placeholder `"generator<EntityName>"` is used here for illustration. <br/> See the **Note** at the beginning of this "Identifier Mappings" section regarding `unsaved-value` and nested `<comment>` elements. |
| `<id name="id" type="long"> <column name="ID"/> <generator class="foreign"> <param name="property">row</param> </generator> </id>` <br/> *Also requires a corresponding HBM `<one-to-one name="row" ... />`* | ID Field: <br/> `@Id` <br/> `@Column(name = "ID")` <br/> <br/> Related `@OneToOne` field (`row`): <br/> `@MapsId` <br/> `@JoinColumn(name = "ID")` <br/> `@OneToOne(fetch = FetchType.LAZY)` | ID Field: <br/> `@org.hibernate.annotations.GenericGenerator( name = "generator<EntityName>", strategy = "foreign", parameters = @org.hibernate.annotations.Parameter(name = "property", value = "row") )` <br/>*(Note: `@GeneratedValue` is typically NOT present on the ID field itself in this strategy, as generation is delegated via `@MapsId`)* | `generator class="foreign"` with `<param name="property">field_name</param>` indicates a derived identifier. The ID is obtained from the associated `@OneToOne` relationship (`field_name`). <br/> - The `@Id` annotated field in the entity (e.g., `private Long id;`) gets the `@GenericGenerator` with `strategy="foreign"`. The `property` parameter points to the `@OneToOne` field. `@GeneratedValue` is typically not used directly on the ID field. <br/> - The corresponding `@OneToOne` field (e.g., `private com.example.CalendarRecurrencyRow row;`) is annotated with `@MapsId` (to indicate it populates the ID) and `@JoinColumn` (referring to the foreign key column which is also the PK column). <br/> - The `name` in `@GenericGenerator` is dynamically generated, typically as `"generator" + <EntityNameSimple>` (e.g., `"generatorFoo"` for entity `Foo`). The placeholder `"generator<EntityName>"` is used here for illustration. <br/> - See the **Note** at the beginning of this "Identifier Mappings" section regarding `unsaved-value` and nested `<comment>` elements. This setup implies a shared primary key scenario. |

---

## Version Mappings (`<version>`)

Covers optimistic locking versioning. Version properties are typically processed by parsing their column information.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<version name="version" type="integer"/>` | `@Version` |  | Maps to a field (e.g., `private Integer version;`) annotated with `@Version`. The `name` and `type` are read from the `<version>` tag. |
| `<version name="timestamp" type="timestamp"> <column name="OBJ_VERSION"/> </version>` | `@Version` <br/> `@Column(name="OBJ_VERSION")` | | The `name` and `type` are read from `<version>`. The column name "OBJ_VERSION" is taken from the nested `<column>` tag. |
<!-- The 'column' attribute directly on <version> is not used for column name if a nested <column> is present. -->


---

## Property Mappings (`<property>`, `<column>`, `<type>`)

Covers basic property/attribute mappings.
This section also includes examples of how nested `<column>` and `<type>` elements within `<property>` are handled.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<property name="myField" type="string"/>` | `@Basic` (often implied) |  | `name` is field name. `type` determines Java field type. |
| `<property name="myField" column="MY_COL"/>` | `@Column(name="MY_COL")` |  | `column` attribute maps to `@Column(name=...)`. |
| `<property name="myField" length="100"/>` | `@Column(length=100)` |  | `length` attribute maps to `@Column(length=...)`. |
| `<property name="myField" update="false"/>` | `@Column(updatable=false)` |  | `update` attribute maps to `updatable=false`. |
| `<property name="lazyField" lazy="true"/>` | `@Basic(fetch=FetchType.LAZY)` |  | `lazy="true"` on a property maps to `@Basic(fetch=FetchType.LAZY)`. |
| `<property name="nonOptimisticField" optimistic-lock="false"/>` | (No direct equivalent) | `@org.hibernate.annotations.OptimisticLock(excluded=true)` | `optimistic-lock="false"` excludes the property from optimistic lock checks. |
| `<property name="myField"> <column name="MY_COL"/> </property>` | `@Column(name="MY_COL")` | | A nested `<column>` tag can define column attributes. |
| `<property name="myField"> <column name="MY_COL" length="100"/> </property>` | `@Column(name="MY_COL", length=100)` | | `length` on nested `<column>`. |
| `<property name="myField"> <column name="MY_COL" not-null="true"/> </property>` | `@Column(name="MY_COL", nullable=false)` | | `not-null="true"` on nested `<column>` maps to `nullable=false`. |
| `<property name="myField"> <column name="MY_COL" unique="true"/> </property>` | `@Column(name="MY_COL", unique=true)` | | `unique="true"` on nested `<column>`. |
| `<property name="myField"> <column name="MY_COL" index="MY_IDX"/> </property>` | `@Index(name="MY_IDX")` (on `@Table` or as part of `@TableGenerator`) | | The `index` attribute on a nested `<column>` maps to an `@Index` annotation. This is typically added to the `@Table` annotation of the entity or relevant join table. |
| `<property name="myField"> <column name="MY_COL" default="DEFAULT_VALUE"/> </property>` |  | `@org.hibernate.annotations.ColumnDefault("DEFAULT_VALUE")` | The `default` attribute on a nested `<column>` maps to Hibernate's `@ColumnDefault`. |
| `<property name="myField"> <column name="MY_COL" unique-key="MY_UK"/> </property>` | `@Column(name="MY_COL", unique=true)` (JPA standard unique constraint) or part of `@Table(uniqueConstraints=...)` | | The `unique-key` attribute on a nested `<column>` contributes to a unique constraint, often mapped to `@Table(uniqueConstraints=@UniqueConstraint(columnNames={"MY_COL"}, name="MY_UK"))`. |
| `<property name="myField"> <column name="MY_COL" sql-type="VARCHAR2(100)"/> </property>` | `@Column(name="MY_COL", columnDefinition="VARCHAR2(100)")` | | The `sql-type` attribute on a nested `<column>` maps to `columnDefinition` in `@Column`. |
| `<property name="amount"> <column name="AMT" precision="10" scale="2"/> </property>` | `@Column(name="AMT", precision=10, scale=2)` | | `precision` and `scale` attributes on a nested `<column>` are mapped to the corresponding attributes in `@Column`. |
| `<property name="status"> <type name="org.hibernate.type.EnumType"> <param name="enumClass">com.example.StatusEnum</param> <param name="useNamed">true</param> <param name="type">12</param> </type> </property>` | (No JPA standard annotation directly, see Hibernate Annotation) | `@org.hibernate.annotations.Type(type = "org.hibernate.type.EnumType", parameters = { @org.hibernate.annotations.Parameter(name="enumClass", value="com.example.StatusEnum"), @org.hibernate.annotations.Parameter(name="useNamed", value="true"), @org.hibernate.annotations.Parameter(name="type", value="12") })` | When HBM specifies `<type name="org.hibernate.type.EnumType">`, `hbm2java` maps this to Hibernate's `@Type` annotation. It does NOT generate `@Enumerated`. Parameters like `enumClass`, `useNamed`, and `type` (for SQL type, e.g., `java.sql.Types.VARCHAR` which is 12) are mapped to the `parameters` attribute of `@Type`. |
| `<property name="customTypeField"> <type name="com.example.MyCustomUserType"/> </property>` |  | `@org.hibernate.annotations.Type(type = "com.example.MyCustomUserType")` | When a specific `UserType` is defined via a nested `<type name="..."/>`, it maps to Hibernate's `@Type`. The `name` attribute of the `<type>` tag and any nested `<param>` elements are read. |
| `<property name="amount" type="com.example.VirtualCurrencyQuantityUserType"> <column name="AMOUNT_VC"/> <column name="AMOUNT_AMOUNT"/> </property>` | Conceptual JPA: <br/> `@Embedded` <br/> `@AttributeOverrides({@AttributeOverride(name="vcField", column=@Column(name="AMOUNT_VC")), @AttributeOverride(name="amountField", column=@Column(name="AMOUNT_AMOUNT"))})` <br/> `private com.example.VirtualCurrencyQuantity amount;` <br/> --- OR if UserType handles multiple columns --- <br/> `@Type(type="com.example.VirtualCurrencyQuantityUserType")` <br/> `@Columns(columns={@org.hibernate.annotations.Column(name="AMOUNT_VC"), @org.hibernate.annotations.Column(name="AMOUNT_AMOUNT")})` <br/> `private com.example.VirtualCurrencyQuantity amount;` | `@org.hibernate.annotations.Columns` is Hibernate-specific. Placeholder field names "vcField", "amountField" used for `@AttributeOverride` example. | A `<property>` with multiple direct `<column>` children typically indicates mapping to a composite type. <br/> If the property's `type` refers to an `@Embeddable` class, the JPA output often uses `@Embedded` and `@AttributeOverrides` to map embeddable attributes to the specified columns. The `name` attributes in `@AttributeOverride` must match field names within the embeddable class. <br/> If the `type` is a Hibernate UserType that handles multiple columns, Hibernate's `@Type` annotation along with `@Columns` would be used. |

---

## Component Mappings (`<component>`, `<properties>`)

Covers embedded object mappings using `<component>`. The `<properties>` tag is for grouping properties, often within a component or a named property group.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<component name="address" class="com.example.Address"> <property name="street"/> </component>` | `@Embedded` <br/> `private com.example.Address address;` <br/> --- <br/> `@Embeddable` <br/> `public class Address { private String street; ... }` |  | The `name` and `class` attributes are read for the component. Nested `<property>` elements are parsed accordingly. The component `class` becomes an `@Embeddable` Java class. |
| `<class name="User"> ... <properties name="nameDetails" unique="true"> <property name="firstName"/> <property name="lastName"/> </properties> </class>` |  If `nameDetails` implies a new Embeddable: <br/> `@Embedded private NameDetails nameDetails;` <br/> --- <br/> `@Embeddable public class NameDetails { ... @Column(unique=true) private String firstName; ...}` <br/> OR (if unique constraint on owning table): <br/> `@Table(uniqueConstraints=@UniqueConstraint(name="nameDetails_UK", columnNames={"firstName_col", "lastName_col"}))`| | The `name` and `unique` attributes are read from `<properties>`. If `unique="true"`, this `name` is used to form a unique constraint name for properties parsed within. A separate `@Embeddable` class might be generated for the properties group, or they might be mapped directly on the entity, applying uniqueness as feasible. |
<!-- Attributes like 'access', 'insert', 'update', 'optimistic-lock', 'node', 'embed-xml' for <component> are not typically processed for direct annotation generation. -->
<!-- For <properties>, attributes like 'node', 'insert', 'update', 'optimistic-lock' are not typically processed. -->

---

## Relationship Mappings (`<many-to-one>`, `<one-to-one>`)

Covers `<many-to-one>` and `<one-to-one>` mappings.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<many-to-one name="user" class="com.example.User"/>` | `@ManyToOne` |  | `name` is field name, `class` is target entity. The default fetch strategy for relationships is often "eager". Since `FetchType.EAGER` is the JPA default for `@ManyToOne`, the `fetch=FetchType.EAGER` attribute is often omitted in the final generated JPA code if the HBM implies eager fetching. |
| `<many-to-one name="user" column="USER_ID"/>` | `@ManyToOne` <br/> `@JoinColumn(name="USER_ID")` |  | The `column` attribute maps to `@JoinColumn(name=...)`. |
| `<many-to-one name="user" cascade="save-update,delete"/>` | `@ManyToOne(cascade={CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE})` |  | `cascade` values are processed according to their HBM to JPA `CascadeType` mappings. For example, "save-update" maps to `CascadeType.PERSIST` and `CascadeType.MERGE`. |
| `<many-to-one name="user" fetch="join"/>` | `@ManyToOne(fetch=FetchType.EAGER)` |  | `fetch="join"` explicitly sets EAGER fetching. This attribute is read, resulting in `fetch=FetchType.EAGER` in JPA. |
| `<many-to-one name="user" fetch="select"/>` | `@ManyToOne(fetch=FetchType.LAZY)` |  | The `fetch="select"` attribute is read. For `@ManyToOne`, this implies LAZY fetching unless `lazy="false"` is also present. Since JPA's default for `@ManyToOne` is EAGER, `fetch=FetchType.LAZY` will be generated if the HBM indicates lazy fetching. |
| `<many-to-one name="user" lazy="proxy"/>` | `@ManyToOne(fetch=FetchType.LAZY)` | | `lazy="proxy"` (or `lazy="true"`) implies LAZY fetching. This is processed and generates `fetch=FetchType.LAZY` in JPA, as it overrides the JPA default (EAGER for `@ManyToOne`). |
| `<many-to-one name="user" lazy="false"/>` | `@ManyToOne` | | `lazy="false"` implies EAGER fetching. As this is the JPA default for `@ManyToOne`, the `fetch=FetchType.EAGER` attribute is often omitted in generated JPA. |
| `<many-to-one name="user" not-null="true"/>` | `@ManyToOne` <br/> `@JoinColumn(nullable=false)` |  | The `not-null="true"` attribute maps to `nullable=false` on `@JoinColumn`. |
| `<many-to-one name="user" unique="true"/>` | `@ManyToOne` <br/> `@JoinColumn(unique=true)` |  | The `unique="true"` attribute maps to `unique=true` on `@JoinColumn`. |
| `<many-to-one name="user" foreign-key="FK_USER_ORDER"/>` | `@ManyToOne` <br/> `@JoinColumn(foreignKey=@ForeignKey(name="FK_USER_ORDER"))` |  | The `foreign-key` attribute specifies a custom foreign key constraint name. |
| `<many-to-one name="user" property-ref="userCode"/>` | `@ManyToOne` <br/> `@JoinColumn(referencedColumnName="userCode")` |  | The `property-ref` attribute maps the foreign key to a non-primary-key column on the target entity. This referenced column must be unique. |
| `<many-to-one name="user" access="field"/>` | `@ManyToOne` <br/> `@Access(AccessType.FIELD)` | | The `access="field"` attribute forces field-based access for this property. |
| `<many-to-one name="user" index="IDX_USER"/>` | `@ManyToOne` <br/> `@JoinColumn(name="USER_ID")` (index applied via `@Table`) | | The `index` attribute on `many-to-one` suggests an index on the foreign key column. This is typically achieved by adding an `@Index` annotation to the `@Table` definition for the column specified in `@JoinColumn`. |
| `<one-to-one name="profile" class="com.example.Profile"/>` | `@OneToOne` |  | `name` and `class` attributes define the relationship as usual. |
| `<one-to-one name="profile" cascade="all"/>` | `@OneToOne(cascade=CascadeType.ALL)` |  | `cascade` maps similarly to many-to-one relationships. |
| `<one-to-one name="profile" constrained="true"/>` | `@OneToOne(optional=false)` <br/> `@MapsId` (common for shared PK) <br/> (The foreign key column is also the primary key column) |  | `constrained="true"` (meaning the relationship is mandatory and typically implies a shared primary key) maps to `@OneToOne(optional=false)`. If the entity's ID is derived from this relationship, `@MapsId` is used. In a shared PK scenario, the join column for the relationship also serves as the primary key. |
| `<one-to-one name="address" property-ref="person"/>` | `@OneToOne(mappedBy="person")` (if `person` is owner field in `Address`) or <br/> `@JoinColumn(referencedColumnName="person")` (if this side is owner and FK refers to non-PK 'person' field in Address) |  | If `property-ref` indicates the `mappedBy` property on the target side of the relationship, then `mappedBy` is used. If it refers to a non-primary-key column on the target for joining, `referencedColumnName` in `@JoinColumn` is used. |
<!-- Removed update="false" for relationships as it's not commonly used directly on the relation annotation itself but rather on the JoinColumn if it's part of an Embeddable or specific cases. The "update" attribute is listed for relationship tags, but its JPA mapping can be nuanced. For now, focusing on more direct mappings. -->

---

## Collection Mappings (`<set>`, `<list>`, `<bag>`, `<map>`, `<key>`, `<one-to-many>`, `<many-to-many>`, `<list-index>`, `<map-key>`, `<composite-map-key>`, `<key-property>`)

Covers various collection types and their specific elements.

**General Collection Attributes & Concepts:**

| HBM Attribute       | Typical JPA/Hibernate Annotation/Concept                                     | Notes                                                                                                                                                                                             |
| :------------------ | :--------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `name`              | Field name in the entity.                                                    | The name of the Java property holding the collection.                                                                                                                                             |
| `table`             | `@JoinTable(name="...")` (for ManyToMany, or OneToMany with join table)       | Specifies the name of the join table. This attribute is read when parsing collection mappings that involve entity relationships (e.g., `<many-to-many>`, or `<one-to-many>` using a join table). HBM `<element>` which would map to `@ElementCollection` and use `@CollectionTable` is not implemented. |
| `lazy`              | `fetch` attribute in `@OneToMany`, `@ManyToMany`, `@ElementCollection`.      | HBM's default for collections is `lazy="true"`. The `lazy` attribute is read and processed. JPA's default for `@OneToMany` and `@ManyToMany` is `FetchType.LAZY`. If `lazy="true"` (or omitted) in HBM, the generated JPA `fetch=FetchType.LAZY` attribute is often omitted as it's the default. `lazy="extra"` also maps to `FetchType.LAZY` (as the specific Hibernate `@LazyCollection` annotation is not generated by the tool). |
| `fetch`             | `fetch` attribute in `@OneToMany`, `@ManyToMany` (e.g., `FetchType.EAGER`, `FetchType.LAZY`) |  | The HBM `fetch` attribute influences the `FetchType` on the JPA relationship annotation. <br/> - `fetch="join"` maps to `FetchType.EAGER`. <br/> - `fetch="select"` (HBM default for collections if `lazy="true"`) maps to `FetchType.LAZY`. <br/> - `fetch="subselect"` also maps to `FetchType.LAZY` (as the specific Hibernate `@Fetch(FetchMode.SUBSELECT)` annotation is not generated by the tool). <br/> If the HBM `fetch` strategy (combined with `lazy`) results in a JPA default (e.g., `FetchType.LAZY` for `@OneToMany`), the explicit `fetch` attribute might be omitted in the generated JPA. |
| `cascade`           | `cascade` attribute in `@OneToMany`, `@ManyToMany`, `@ElementCollection`.      | HBM cascade options (e.g., "all", "save-update", "delete") map to `CascadeType` values (e.g., `ALL`, `PERSIST`, `MERGE`, `REMOVE`). `delete-orphan` is separate (`orphanRemoval=true`). |
| `inverse="true"`    | `mappedBy="..."` attribute in `@OneToMany`, `@ManyToMany`.                     | Indicates the collection is the inverse (non-owning) side of a bidirectional relationship. The `mappedBy` value is the name of the property on the owning side.                                        |
| `order-by`          | `@OrderBy("column_name asc/desc, ...")`                                      | For collections of entities, specifies a DB-level ordering. `column_name` refers to a column in the target entity's table.                                                                       |

**The `<key>` Element:**

| HBM Attribute (`<key>`) | JPA Annotation(s)                                                                 | Notes                                                                                                                               |
| :---------------------- | :-------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------- |
| `column`                | `@JoinColumn(name="...")` (within `@JoinTable` or directly on collection attribute) | Specifies the foreign key column name in the collection/join table or child table.                                                       |
| `foreign-key`           | `@JoinColumn(foreignKey=@ForeignKey(name="..."))`                                 | Specifies a custom name for the foreign key constraint.                                                                             |

---
**Specific Collection Tag Mappings:**

| HBM XML Snippet (General Attributes)                                       | JPA Annotation(s) & Collection Type                                                                                                | Hibernate Annotation(s) (if needed) | Notes                                                                                                                                                                                                                                                           |
| :------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `<set name="items" table="ITEM_SET_TABLE" lazy="true" fetch="select" cascade="all" inverse="false" order-by="name asc"> <key column="OWNER_ID"/> ... </set>` | `private java.util.Set<Item> items;` <br/> `@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.LAZY)` or `@ManyToMany(...)` <br/> `@JoinTable(name="ITEM_SET_TABLE", joinColumns=@JoinColumn(name="OWNER_ID"))` (if join table used) <br/> `@OrderBy("name asc")` |  | `hbm2java` maps `<set>` to `java.util.Set`. Attributes like `table`, `lazy`, `fetch`, `cascade`, `inverse`, `order-by` are applied as shown. `<key>` maps to `@JoinColumn`. HBM `fetch="select"` (often with `lazy="true"`) results in `FetchType.LAZY`. Specific content of set (e.g. `<one-to-many>`) determines full mapping. HBM `<element>` is not implemented. |
| `<list name="tasks" table="TASK_LIST_TABLE" cascade="persist" lazy="extra"> <key column="TODO_ID"/> ... </list>` | `private java.util.List<Task> tasks;` <br/> `@OneToMany(cascade=CascadeType.PERSIST, fetch=FetchType.LAZY)` or `@ManyToMany(...)` <br/> `@JoinTable(name="TASK_LIST_TABLE", joinColumns=@JoinColumn(name="TODO_ID"))` (if join table used) <br/> `@OrderColumn` (if `<list-index>` present) |  | `hbm2java` maps `<list>` to `java.util.List`. `lazy="extra"` results in `FetchType.LAZY` as the specific Hibernate `@LazyCollection` annotation is not generated by the tool. Presence of `<list-index>` (covered later) adds `@OrderColumn`. Specific content (e.g. `<one-to-many>`) determines full mapping. HBM `<element>` is not implemented. |
| `<bag name="events" lazy="false" fetch="join" access="field"> <key column="EVENT_OWNER_ID"/> ... </bag>` | `private java.util.Collection<Event> events;` <br/> `@OneToMany(fetch=FetchType.EAGER)` or `@ManyToMany(fetch=FetchType.EAGER)` <br/> `@Access(AccessType.FIELD)` |  | `hbm2java` typically maps `<bag>` to `java.util.Collection` or `java.util.List` if no `order-by` is specified. HBM `fetch="join"` results in `FetchType.EAGER`. Attributes are mapped similarly. Bags are unordered and may allow duplicates. Specific content (e.g. `<one-to-many>`) determines full mapping. HBM `<element>` is not implemented. |
| `<map name="attributes" table="ATTRIBUTES_MAP" order-by="key_col desc"> <key column="ENTITY_ID"/> <map-key column="ATTR_NAME" type="string"/> <one-to-many class="com.example.MapValueEntity"/> </map>` | `private java.util.Map<String, com.example.MapValueEntity> attributes;` <br/> `@OneToMany` <br/> `@JoinTable(name="ATTRIBUTES_MAP", joinColumns=@JoinColumn(name="ENTITY_ID"))` <br/> `@MapKeyColumn(name="ATTR_NAME")` <br/> `@OrderBy("key_col desc")` |  | A `<map>` element maps to `java.util.Map`. Attributes `name`, `table`, and `order-by` are translated. The `schema` and `catalog` attributes on HBM `<map>` are not implemented for annotation generation. Key mapping is via `<map-key>` (to `@MapKeyColumn`) or `<map-key-many-to-many>`. Value mapping for entity types is via `<one-to-many>` or `<many-to-many>`. HBM `<element>` for mapping basic/embeddable value types (which would typically use `@ElementCollection`) is not currently implemented. |

---

**Note on HBM `<element>` for Collections:** The HBM `<element>` tag, which would typically be used for mapping collections of basic or embeddable types (often translating to JPA's `@ElementCollection`), is **not implemented** in this version of the `hbm2java` tool. Therefore, direct mapping of such collections using `<element>` is not supported.
## Inheritance Mappings

Covers inheritance strategies. `<subclass>` and `<union-subclass>` are primarily handled in the "Class Mappings" section. This section focuses on elements that define the inheritance strategy itself (`<discriminator>`) and additional tables for joined inheritance (`<join>`).

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal"> <id name="id"/> <discriminator type="string"/> ... </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` <br/> `@DiscriminatorColumn(discriminatorType=DiscriminatorType.STRING)` |  | For `SINGLE_TABLE` inheritance. The `type` attribute of `<discriminator>` is read. If a nested `<column>` is not present, the discriminator column name defaults to "DTYPE" and length is not set. The `formula` attribute for `<discriminator>` is not typically processed for standard JPA annotations. |
| `<class name="Animal"> <id name="id"/> <discriminator type="integer"> <column name="ANIMAL_TYPE" length="4"/> </discriminator> ... </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` <br/> `@DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.INTEGER, length=4)` |  | The `type` attribute on `<discriminator>` maps to `discriminatorType`. The `name` and `length` attributes from a nested `<column>` tag are read for the discriminator column. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy, the `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass entity. This specifies the foreign key column in the subclass table that joins to the primary key of the superclass table. This is different from the `pkJoinColumns` attribute used with `@SecondaryTable`. The `table` attribute on `<joined-subclass>` is handled by `@Table` on the subclass. These elements are processed during class and entity parsing. |
| `<class name="Foo" table="MAIN_FOO"> ... <join table="JOIN_FOO"> <key column="FOO_ID"/> <property name="joinedProp"/> </join> ... </class>` | `@SecondaryTable(name="JOIN_FOO", pkJoinColumns=@PrimaryKeyJoinColumn(name="FOO_ID"))` (on class `Foo`) <br/> `@Column(table="JOIN_FOO")` (on `joinedProp` field) |  | The `<join>` tag is handled during entity parsing. The `table` attribute of `<join>` specifies the secondary table name. The nested `<key column="..."/>` defines the `@PrimaryKeyJoinColumn` used within the `pkJoinColumns` attribute of `@SecondaryTable`. Properties within the `<join>` block are mapped to this secondary table. |
<!-- Union-subclass is covered in Class Mappings. -->

---

## Cache Mappings (`<cache>`)

Covers entity and collection caching.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Foo"> <cache usage="read-only"/> ... </class>` | `@Cacheable` (often implied by JPA provider if L2 cache enabled) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_ONLY)` | The `usage` attribute from a `<cache>` element directly under `<class>` is read during entity parsing. The `region` attribute is not typically processed for standard JPA caching annotations. |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)` | The `usage` attribute from a `<cache>` element nested within a collection tag is read during collection parsing. The `region` attribute is not typically processed for standard JPA caching annotations. |
<!-- Other <cache> attributes like 'include' are not typically processed. -->
---

## Natural ID Mappings (`<natural-id>`)

Covers mapping of natural business keys. Natural ID properties are parsed accordingly.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId` | If `mutable="true"`: `@org.hibernate.annotations.NaturalId(mutable=true)` <br/> Else (default `mutable="false"`): `@org.hibernate.annotations.NaturalId(mutable=false)` (or just `@NaturalId`) | The `mutable` attribute of `<natural-id>` is read. Nested `<property>` and `<many-to-one>` elements are parsed to become part of the natural ID. |
<!-- A nested <cache> element specifically for <natural-id> is not typically parsed for standard JPA/Hibernate annotations beyond general entity/collection caching. -->

---

## Query Mappings (`<query>`, `<sql-query>`, `<return-scalar>`)

Covers named HQL and SQL queries. Query definitions and their return types are parsed.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity or in `package-info.java`) |  | The `name` attribute and the CDATA content for the HQL query are read. |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <return-scalar column="user_age" type="integer"/> <![CDATA[ SELECT name AS user_name, age AS user_age FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name, age AS user_age FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name", type=String.class), @ColumnResult(name="user_age", type=Integer.class)})` |  | The `name` attribute and CDATA content for the SQL query are read. Nested `<return-scalar>` elements are processed, reading their `column` and `type` attributes. The `type` on `@ColumnResult` can be set based on the HBM type. |
<!-- Only <return-scalar> is typically processed for standard JPA annotation generation from <sql-query> children. Other elements like <return alias="..." class="..."> or <return-join...> might require more complex or Hibernate-specific handling. -->
<!-- Attributes for <query> and <sql-query> like 'cacheable', 'cache-region', 'fetch-size', 'timeout', 'read-only', 'callable', 'comment' are not typically processed for standard JPA annotation generation. -->

---

**Note on HBM `<element>` for Collections:** The HBM `<element>` tag, which would typically be used for mapping collections of basic or embeddable types (often translating to JPA's `@ElementCollection`), is **not implemented** in this version of the `hbm2java` tool. Therefore, direct mapping of such collections using `<element>` is not supported.
<!-- Persister, filter-def, filter, optimistic-lock attribute on class are not implemented. -->

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
---

**Note on HBM `<element>` for Collections:** The HBM `<element>` tag, which would typically be used for mapping collections of basic or embeddable types (often translating to JPA's `@ElementCollection`), is **not implemented** in this version of the `hbm2java` tool. Therefore, direct mapping of such collections using `<element>` is not supported.
<!-- Persister, filter-def, filter, optimistic-lock attribute on class are not implemented. -->

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator type="string"><column name="ANIMAL_TYPE" length="20"/></discriminator> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance. The `type` attribute on `<discriminator>` maps to `discriminatorType`. Attributes like `name` (for column name) and `length` are specified on a nested `<column>` tag within `<discriminator>` and map to `@DiscriminatorColumn`. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | | The `type` attribute on the discriminator informs Hibernate about the expected type. If a formula was used, it's not a standard JPA feature and would be handled by Hibernate-specific annotations if the conversion process supports it. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. A `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending the superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. This is mapped by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though direct mapping might occur if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |

---

## Relationship Mappings

Covers `<many-to-one>` and `<one-to-one>` mappings.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator column="ANIMAL_TYPE" type="string" length="20"/> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance (default when `<discriminator>` is present without `<joined-subclass>` or `<union-subclass>`). `discriminator column` maps to `@DiscriminatorColumn name`. `type` maps to `discriminatorType` (STRING, CHAR, INTEGER). `length` is also set. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator formula="CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END" type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | `@org.hibernate.annotations.DiscriminatorFormula("CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END")` | If `formula` is used on `<discriminator>`, it maps to Hibernate's `@DiscriminatorFormula`. `type` on discriminator still informs Hibernate about the expected type of the formula's result. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. `hbm2java` maps this by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though `hbm2java` might map them directly if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity, or in a central place like `package-info.java`) |  | HQL query defined in CDATA section is mapped to the `query` attribute of `@NamedQuery`. `name` attribute is used for `name`. `hbm2java` typically adds these to the relevant entity class. |
| `<sql-query name="findUserWithAddress"> <return alias="user" class="com.example.User"/> <return-join alias="addr" property="user.address"/> <![CDATA[ SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ? ]]> </sql-query>` | `@NamedNativeQuery(name="findUserWithAddress", query="SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ?", resultSetMapping="userWithAddressMapping")` <br/> `@SqlResultSetMapping(name="userWithAddressMapping", entities={@EntityResult(entityClass=com.example.User.class, alias="user", fields={@FieldResult(name="address", column="addr")})})` (Note: `FieldResult` for `return-join` is simplified here; `hbm2java` might map `return-join` to a separate `@EntityResult` if `addr` is an entity, or handle it as part of the main `EntityResult`'s fields if the join is to populate a property of `user`.) |  | SQL query maps to `@NamedNativeQuery`. `<return alias="..." class="..."/>` maps to `@EntityResult(entityClass=...)`. `<return-join property="user.address"/>` (populating a property of the main return) maps to `@FieldResult` within the main `@EntityResult`. A `resultSetMapping` name is generated. If the join returns another full entity, it would be a separate `@EntityResult`. |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <return-scalar column="user_age" type="integer"/> <![CDATA[ SELECT name AS user_name, age AS user_age FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name, age AS user_age FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name", type=String.class), @ColumnResult(name="user_age", type=Integer.class)})` |  | `<return-scalar column="..." type="..."/>` maps to `@ColumnResult(name="...", type=...)` within a `@SqlResultSetMapping`. `hbm2java` derives the Java type from HBM type. |
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber" column="EMP_NO"/> <many-to-one name="department" column="DEPT_ID"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId @Column(name="EMP_NO")` <br/> On `department` field: `@NaturalId @ManyToOne @JoinColumn(name="DEPT_ID")` | `@org.hibernate.annotations.NaturalIdCache` (on class `Employee`, if `<cache>` is also used for natural-id) | Properties within `<natural-id>` are annotated with `@NaturalId`. `mutable="true"` on `<natural-id>` maps to `@NaturalId(mutable=true)` on each field. If a `<cache>` element is associated with the natural ID in HBM (not shown), `@NaturalIdCache` might be added to the entity. `hbm2java` handles this. |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied, or explicitly if needed for provider) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)` | `<cache usage="..."/>` nested within a collection tag (like `<set>`, `<list>`, etc.) maps to Hibernate's `@Cache` annotation on the collection field. `usage` maps to `CacheConcurrencyStrategy`. `region` is a separate attribute on Hibernate's `@Cache`. |

---

## Collection Mappings

Covers various collection types like `<set>`, `<list>`, `<map>`, etc., including `<one-to-many>` and `<many-to-many>` within them.

**General Collection Attributes & Concepts:**

Many attributes are common across different collection mapping tags (`<set>`, `<list>`, `<bag>`, `<map>`). These are generally translated as follows:

| HBM Attribute       | Typical JPA/Hibernate Annotation/Concept                                     | Notes                                                                                                                                                                                             |
| :------------------ | :--------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `name`              | Field name in the entity.                                                    | The name of the Java property holding the collection.                                                                                                                                             |
| `table`             | `@JoinTable(name="...")` (for ManyToMany, or OneToMany with join table), `@CollectionTable(name="...")` (for ElementCollection) | Specifies the name of the join table or collection table.                                                                                                                                         |
| `lazy`              | `fetch` attribute in `@OneToMany`, `@ManyToMany`, `@ElementCollection`.      | `lazy="true"` (default) maps to `FetchType.LAZY`. `lazy="false"` maps to `FetchType.EAGER`. `lazy="extra"` maps to `FetchType.LAZY` and enables Hibernate's "extra-lazy" behavior (e.g., `size()` doesn't load all elements). Hibernate's `@LazyCollection(LazyCollectionOption.EXTRA)` might be used for "extra". |
| `fetch`             | `@org.hibernate.annotations.Fetch(FetchMode.SELECT/JOIN/SUBSELECT)`          | `fetch="select"` (default) is standard lazy/eager loading. `fetch="join"` implies EAGER with a join. `fetch="subselect"` uses a subselect to fetch collections for multiple parent entities.         |
| `cascade`           | `cascade` attribute in `@OneToMany`, `@ManyToMany`, `@ElementCollection`.      | HBM cascade options (e.g., "all", "save-update", "delete", "delete-orphan") map to `CascadeType` values (e.g., `ALL`, `PERSIST`, `MERGE`, `REMOVE`, `DETACH`, `REFRESH`). `delete-orphan` maps to `orphanRemoval=true`. |
| `inverse="true"`    | `mappedBy="..."` attribute in `@OneToMany`, `@ManyToMany`.                     | Indicates the collection is the inverse (non-owning) side of a bidirectional relationship. The `mappedBy` value is the name of the property on the owning side.                                        |
| `order-by`          | `@OrderBy("column_name asc/desc, ...")`                                      | For collections of entities, specifies a DB-level ordering. `column_name` refers to a column in the target entity's table.                                                                       |

**The `<key>` Element:**

The `<key>` element within a collection mapping is crucial for defining the foreign key in the collection table (for `@ElementCollection` or join tables in `@ManyToMany`/`@ManyToMany`) or in the child table (for `@OneToMany` without a join table) that refers back to the owning entity's primary key.

| HBM Attribute (`<key>`) | JPA Annotation(s)                                                                 | Notes                                                                                                                               |
| :---------------------- | :-------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------- |
| `column`                | `@JoinColumn(name="...")` (within `@JoinTable` or directly on collection attribute) | Specifies the foreign key column name in the collection/join table or child table.                                                       |
| `foreign-key`           | `@JoinColumn(foreignKey=@ForeignKey(name="..."))`                                 | Specifies a custom name for the foreign key constraint.                                                                             |

---
**Specific Collection Tag Mappings:**

| HBM XML Snippet (General Attributes)                                       | JPA Annotation(s) & Collection Type                                                                                                | Hibernate Annotation(s) (if needed) | Notes                                                                                                                                                                                                                                                           |
| :------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `<set name="items" table="ITEM_SET_TABLE" lazy="true" fetch="select" cascade="all" inverse="false" order-by="name asc"> <key column="OWNER_ID"/> ... </set>` | `private java.util.Set<Item> items;` <br/> `@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.LAZY)` or `@ManyToMany(...)` <br/> `@JoinTable(name="ITEM_SET_TABLE", joinColumns=@JoinColumn(name="OWNER_ID"))` (if join table used) <br/> `@OrderBy("name asc")` | `@org.hibernate.annotations.Fetch(FetchMode.SELECT)` | A `<set>` element maps to `java.util.Set`. Attributes like `table`, `lazy`, `fetch`, `cascade`, `inverse`, `order-by` are applied as shown. `<key>` maps to `@JoinColumn`. Specific content of set (e.g. `<element>`, `<one-to-many>`) determines full mapping. HBM `fetch="select"` contributes to `FetchType.LAZY`. |
| `<list name="tasks" table="TASK_LIST_TABLE" cascade="persist" lazy="extra"> <key column="TODO_ID"/> ... </list>` | `private java.util.List<Task> tasks;` <br/> `@OneToMany(cascade=CascadeType.PERSIST, fetch=FetchType.LAZY)` or `@ManyToMany(...)` <br/> `@JoinTable(name="TASK_LIST_TABLE", joinColumns=@JoinColumn(name="TODO_ID"))` (if join table used) <br/> `@OrderColumn` (if `<list-index>` present) | `@org.hibernate.annotations.LazyCollection(LazyCollectionOption.EXTRA)` | A `<list>` element maps to `java.util.List`. `lazy="extra"` maps to `@LazyCollection(LazyCollectionOption.EXTRA)`. Presence of `<list-index>` (covered later) adds `@OrderColumn`. |
| `<bag name="events" lazy="false" fetch="join" access="field"> <key column="EVENT_OWNER_ID"/> ... </bag>` | `private java.util.Collection<Event> events;` <br/> `@OneToMany(fetch=FetchType.EAGER)` or `@ManyToMany(fetch=FetchType.EAGER)` <br/> `@Access(AccessType.FIELD)` | `@org.hibernate.annotations.Fetch(FetchMode.JOIN)` | A `<bag>` element typically maps to `java.util.Collection` or `java.util.List` if no `order-by` is specified. Attributes are mapped similarly. Bags are unordered and may allow duplicates. HBM `fetch="join"` contributes to `FetchType.EAGER`. |
| `<map name="attributes" table="ATTRIBUTES_MAP" order-by="key_col desc"> <key column="ENTITY_ID"/> ... </map>` | `private java.util.Map<String, String> attributes;` <br/> `@ElementCollection` or `@OneToMany`/`@ManyToMany` <br/> `@CollectionTable(name="ATTRIBUTES_MAP", joinColumns=@JoinColumn(name="ENTITY_ID"))` (for ElementCollection) <br/> `@MapKeyColumn(...)` or `@MapKeyJoinColumn(...)` or `@MapKeyEnumerated(...)` etc. (covered later) <br/> `@OrderBy("key_col desc")` |  | A `<map>` element maps to `java.util.Map`. Attributes `name`, `table`, and `order-by` are translated to corresponding annotations. The `schema` and `catalog` attributes on the HBM `<map>` tag are not implemented/translated for annotation generation. Key/Value mapping details (e.g. `<map-key>`, `<element>`) determine the full annotations. |
| `<set name="items" table="ITEM_SET_TABLE" lazy="true" fetch="select" cascade="all" inverse="false" order-by="name asc"> <key column="OWNER_ID"/> ... </set>` | `private java.util.Set<Item> items;` <br/> `@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.LAZY)` or `@ManyToMany(...)` <br/> `@JoinTable(name="ITEM_SET_TABLE", joinColumns=@JoinColumn(name="OWNER_ID"))` (if join table used) <br/> `@OrderBy("name asc")` |  | `hbm2java` maps `<set>` to `java.util.Set`. Attributes like `table`, `lazy`, `fetch`, `cascade`, `inverse`, `order-by` are applied as shown. `<key>` maps to `@JoinColumn`. HBM `fetch="select"` (often with `lazy="true"`) results in `FetchType.LAZY`. Specific content of set (e.g. `<one-to-many>`) determines full mapping. HBM `<element>` is not implemented. |
| `<list name="tasks" table="TASK_LIST_TABLE" cascade="persist" lazy="extra"> <key column="TODO_ID"/> ... </list>` | `private java.util.List<Task> tasks;` <br/> `@OneToMany(cascade=CascadeType.PERSIST, fetch=FetchType.LAZY)` or `@ManyToMany(...)` <br/> `@JoinTable(name="TASK_LIST_TABLE", joinColumns=@JoinColumn(name="TODO_ID"))` (if join table used) <br/> `@OrderColumn` (if `<list-index>` present) |  | `hbm2java` maps `<list>` to `java.util.List`. `lazy="extra"` results in `FetchType.LAZY` as the specific Hibernate `@LazyCollection` annotation is not generated by the tool. Presence of `<list-index>` (covered later) adds `@OrderColumn`. Specific content (e.g. `<one-to-many>`) determines full mapping. HBM `<element>` is not implemented. |
| `<bag name="events" lazy="false" fetch="join" access="field"> <key column="EVENT_OWNER_ID"/> ... </bag>` | `private java.util.Collection<Event> events;` <br/> `@OneToMany(fetch=FetchType.EAGER)` or `@ManyToMany(fetch=FetchType.EAGER)` <br/> `@Access(AccessType.FIELD)` |  | `hbm2java` typically maps `<bag>` to `java.util.Collection` or `java.util.List` if no `order-by` is specified. HBM `fetch="join"` results in `FetchType.EAGER`. Attributes are mapped similarly. Bags are unordered and may allow duplicates. Specific content (e.g. `<one-to-many>`) determines full mapping. HBM `<element>` is not implemented. |
| `<map name="attributes" table="ATTRIBUTES_MAP" order-by="key_col desc"> <key column="ENTITY_ID"/> <map-key column="ATTR_NAME" type="string"/> <one-to-many class="com.example.MapValueEntity"/> </map>` | `private java.util.Map<String, com.example.MapValueEntity> attributes;` <br/> `@OneToMany` <br/> `@JoinTable(name="ATTRIBUTES_MAP", joinColumns=@JoinColumn(name="ENTITY_ID"))` <br/> `@MapKeyColumn(name="ATTR_NAME")` <br/> `@OrderBy("key_col desc")` |  | `hbm2java` maps `<map>` to `java.util.Map`. Attributes `name`, `table`, and `order-by` are translated. The `schema` and `catalog` attributes on HBM `<map>` are not implemented for annotation generation. Key mapping is via `<map-key>` (to `@MapKeyColumn`) or `<map-key-many-to-many>`. Value mapping for entity types is via `<one-to-many>` or `<many-to-many>`. HBM `<element>` for mapping basic/embeddable value types to `@ElementCollection` is not currently implemented. |

---

**Note on HBM `<element>` for Collections:** The HBM `<element>` tag, which would typically be used for mapping collections of basic or embeddable types (often translating to JPA's `@ElementCollection`), is **not implemented** in this version of the `hbm2java` tool. Therefore, direct mapping of such collections using `<element>` is not supported.

<!--
The following table was the "Collection Element Mappings" section. It is removed because the <element> tag for basic/embeddable collections is not implemented.

| HBM XML Snippet (Nested Element)                                                                                                | JPA Annotation(s) on Collection Field / Related Annotations                                                                                                                                                                                                                                                              | Notes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| :------------------------------------------------------------------------------------------------------------------------------ | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`<one-to-many>` (Nested)** <br/> `<set name="phones"> <key column="OWNER_ID"/> <one-to-many class="com.example.Phone"/> </set>`                                                | `java.util.Set<Phone> phones;` <br/> `@OneToMany(mappedBy="ownerFieldInPhone")` (assuming bidirectional) or `@OneToMany @JoinColumn(name="OWNER_ID")` (if unidirectional and `OWNER_ID` is in `Phone` table)                                                                                                                            | `<one-to-many class="..."/>` defines the target entity. Default fetch for `@OneToMany` is LAZY. If the collection's HBM attributes (like `lazy="true"`, which is default for collections) result in LAZY fetch, the generated JPA `@OneToMany` might omit `fetch=FetchType.LAZY` as it's the JPA default. |
| **`<many-to-many>` (Nested)** <br/> `<set name="courses" table="STUDENT_COURSES"> <key column="STUDENT_ID"/> <many-to-many class="com.example.Course" column="COURSE_ID" foreign-key="FK_COURSE_IN_JT"/> </set>` | `java.util.Set<Course> courses;` <br/> `@ManyToMany` <br/> `@JoinTable(name="STUDENT_COURSES", joinColumns=@JoinColumn(name="STUDENT_ID"), inverseJoinColumns=@JoinColumn(name="COURSE_ID", foreignKey=@ForeignKey(name="FK_COURSE_IN_JT")) )`                                                                                                  | `<many-to-many class="..." column="..."/>` maps to `@ManyToMany`. `table` attribute of parent collection tag becomes `@JoinTable(name=...)`. The `<key column="..."/>` (sibling to `<many-to-many>`) defines the `joinColumns` (FK for owning entity). The `column` attribute of `<many-to-many>` defines the `inverseJoinColumns` (FK for target entity). `foreign-key` on `<many-to-many>` applies to the `inverseJoinColumns`'s FK constraint. |
| **`<list-index>` (for `<list>`)** <br/> `<list name="chapters"> <key column="BOOK_ID"/> <list-index column="chapter_num"/> <one-to-many class="Chapter"/> </list>`       | `java.util.List<Chapter> chapters;` <br/> `@OneToMany(...)` (or `@ManyToMany(...)`) <br/> `@OrderColumn(name="chapter_num")`                                                                                                                                                                                                | <!-- @org.hibernate.annotations.ListIndexBase(1) (if `base` attribute is present) -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | `<list-index>` inside a `<list>` mapping adds an `@OrderColumn(name="...")` to maintain the list order in the database. The `column` attribute specifies the name of this index column. The `base` attribute (Hibernate-specific) can be used to set the starting value of the index, mapped to `@ListIndexBase`. `hbm2java` usually places this on the join table if one exists, or the target table for one-to-many. |
| **`<composite-map-key>` (Embeddable for `<map>`)** <br/> `<map name="customReports" table="USER_REPORTS"> <key column="USER_ID"/> <composite-map-key class="com.example.ReportKey"> <key-property name="reportName"/> <key-property name="reportVersion"/> </composite-map-key> <one-to-many class="com.example.ReportData"/> </map>` | `java.util.Map<ReportKey, ReportData> customReports;` <br/> `@OneToMany` (or `@ManyToMany`, `@ElementCollection` for values) <br/> `@MapKeyClass(ReportKey.class)` <br/> `// Column mapping for ReportKey fields done via @MapKeyColumn on those fields, or @AttributeOverrides on the collection if columns were in HBM.` | `com.example.ReportKey` must be an `@Embeddable` class. `<composite-map-key>` maps to `@MapKeyClass`. The properties of the map key embeddable (`<key-property>`) are mapped to columns in the join/collection table. `hbm2java` would typically expect these columns to be defined within the HBM for the map key or rely on defaults/overrides. The example shows the setup; actual column names for map key parts depend on how `ReportKey` is defined or if overrides are specified. |
-->
## Inheritance Mappings

Covers `<subclass>`, `<joined-subclass>`, `<union-subclass>`, and `<discriminator>`.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator column="ANIMAL_TYPE" type="string" length="20"/> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance (default when `<discriminator>` is present without `<joined-subclass>` or `<union-subclass>`). `discriminator column` maps to `@DiscriminatorColumn name`. `type` maps to `discriminatorType` (STRING, CHAR, INTEGER). `length` is also set. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator formula="CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END" type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | `@org.hibernate.annotations.DiscriminatorFormula("CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END")` | If `formula` is used on `<discriminator>`, it maps to Hibernate's `@DiscriminatorFormula`. `type` on discriminator still informs Hibernate about the expected type of the formula's result. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. `hbm2java` maps this by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though `hbm2java` might map them directly if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity, or in a central place like `package-info.java`) |  | HQL query defined in CDATA section is mapped to the `query` attribute of `@NamedQuery`. `name` attribute is used for `name`. `hbm2java` typically adds these to the relevant entity class. |
| `<sql-query name="findUserWithAddress"> <return alias="user" class="com.example.User"/> <return-join alias="addr" property="user.address"/> <![CDATA[ SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ? ]]> </sql-query>` | `@NamedNativeQuery(name="findUserWithAddress", query="SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ?", resultSetMapping="userWithAddressMapping")` <br/> `@SqlResultSetMapping(name="userWithAddressMapping", entities={@EntityResult(entityClass=com.example.User.class, alias="user", fields={@FieldResult(name="address", column="addr")})})` (Note: `FieldResult` for `return-join` is simplified here; `hbm2java` might map `return-join` to a separate `@EntityResult` if `addr` is an entity, or handle it as part of the main `EntityResult`'s fields if the join is to populate a property of `user`.) |  | SQL query maps to `@NamedNativeQuery`. `<return alias="..." class="..."/>` maps to `@EntityResult(entityClass=...)`. `<return-join property="user.address"/>` (populating a property of the main return) maps to `@FieldResult` within the main `@EntityResult`. A `resultSetMapping` name is generated. If the join returns another full entity, it would be a separate `@EntityResult`. |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <return-scalar column="user_age" type="integer"/> <![CDATA[ SELECT name AS user_name, age AS user_age FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name, age AS user_age FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name", type=String.class), @ColumnResult(name="user_age", type=Integer.class)})` |  | `<return-scalar column="..." type="..."/>` maps to `@ColumnResult(name="...", type=...)` within a `@SqlResultSetMapping`. `hbm2java` derives the Java type from HBM type. |
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber" column="EMP_NO"/> <many-to-one name="department" column="DEPT_ID"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId @Column(name="EMP_NO")` <br/> On `department` field: `@NaturalId @ManyToOne @JoinColumn(name="DEPT_ID")` | `@org.hibernate.annotations.NaturalIdCache` (on class `Employee`, if `<cache>` is also used for natural-id) | Properties within `<natural-id>` are annotated with `@NaturalId`. `mutable="true"` on `<natural-id>` maps to `@NaturalId(mutable=true)` on each field. If a `<cache>` element is associated with the natural ID in HBM (not shown), `@NaturalIdCache` might be added to the entity. `hbm2java` handles this. |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write" region="itemCache"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied, or explicitly if needed for provider) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region="itemCache")` | `<cache usage="..." region="..."/>` nested within a collection tag (like `<set>`, `<list>`, etc.) maps to Hibernate's `@Cache` annotation on the collection field. `usage` maps to `CacheConcurrencyStrategy`. |
| `<class name="MyEntity" optimistic-lock="version"> ... </class>` | (Implicit default if `@Version` is present) |  | `optimistic-lock="version"` (default) implies use of a `<version>` property. `optimistic-lock="all"` would check all fields (less common). `optimistic-lock="dirty"` checks only modified fields. JPA default with `@Version` is similar to "version". `hbm2java` reflects this in generated code, but no specific annotation for "version" itself beyond `@Version` on a property. |
| `<class name="MyEntity" persister="com.example.MyPersister"> ... </class>` | (No direct equivalent) | `@org.hibernate.annotations.Persister(impl=com.example.MyPersister.class)` | `persister` attribute maps to Hibernate's `@Persister` annotation. |
| `<filter-def name="myFilter"> <filter-param name="myParam" type="string"/> </filter-def>` <br/> `<class ...> <filter name="myFilter" condition=":myParam = some_column"/> </class>` | (No direct equivalent for filter definitions. Filters are applied programmatically in JPA.) | `@org.hibernate.annotations.FilterDef(name="myFilter", parameters={@org.hibernate.annotations.ParamDef(name="myParam", type="string")})` (on a class, often package-level) <br/> `@org.hibernate.annotations.Filter(name="myFilter", condition=":myParam = some_column")` (on entity or collection) | `hbm2java` maps `<filter-def>` to `@FilterDef` (often at package level or on a common entity) and `<filter>` to `@Filter` on the specific entity/collection. |

---

## Query Mappings

Covers `<query>` and `<sql-query>`.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator column="ANIMAL_TYPE" type="string" length="20"/> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance (default when `<discriminator>` is present without `<joined-subclass>` or `<union-subclass>`). `discriminator column` maps to `@DiscriminatorColumn name`. `type` maps to `discriminatorType` (STRING, CHAR, INTEGER). `length` is also set. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator formula="CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END" type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | `@org.hibernate.annotations.DiscriminatorFormula("CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END")` | If `formula` is used on `<discriminator>`, it maps to Hibernate's `@DiscriminatorFormula`. `type` on discriminator still informs Hibernate about the expected type of the formula's result. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. `hbm2java` maps this by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though `hbm2java` might map them directly if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity, or in a central place like `package-info.java`) |  | HQL query defined in CDATA section is mapped to the `query` attribute of `@NamedQuery`. `name` attribute is used for `name`. `hbm2java` typically adds these to the relevant entity class. |
| `<sql-query name="findUserWithAddress"> <return alias="user" class="com.example.User"/> <return-join alias="addr" property="user.address"/> <![CDATA[ SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ? ]]> </sql-query>` | `@NamedNativeQuery(name="findUserWithAddress", query="SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ?", resultSetMapping="userWithAddressMapping")` <br/> `@SqlResultSetMapping(name="userWithAddressMapping", entities={@EntityResult(entityClass=com.example.User.class, alias="user", fields={@FieldResult(name="address", column="addr")})})` (Note: `FieldResult` for `return-join` is simplified here; `hbm2java` might map `return-join` to a separate `@EntityResult` if `addr` is an entity, or handle it as part of the main `EntityResult`'s fields if the join is to populate a property of `user`.) |  | SQL query maps to `@NamedNativeQuery`. `<return alias="..." class="..."/>` maps to `@EntityResult(entityClass=...)`. `<return-join property="user.address"/>` (populating a property of the main return) maps to `@FieldResult` within the main `@EntityResult`. A `resultSetMapping` name is generated. If the join returns another full entity, it would be a separate `@EntityResult`. |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <return-scalar column="user_age" type="integer"/> <![CDATA[ SELECT name AS user_name, age AS user_age FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name, age AS user_age FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name", type=String.class), @ColumnResult(name="user_age", type=Integer.class)})` |  | `<return-scalar column="..." type="..."/>` maps to `@ColumnResult(name="...", type=...)` within a `@SqlResultSetMapping`. `hbm2java` derives the Java type from HBM type. |
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber" column="EMP_NO"/> <many-to-one name="department" column="DEPT_ID"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId @Column(name="EMP_NO")` <br/> On `department` field: `@NaturalId @ManyToOne @JoinColumn(name="DEPT_ID")` | `@org.hibernate.annotations.NaturalIdCache` (on class `Employee`, if `<cache>` is also used for natural-id) | Properties within `<natural-id>` are annotated with `@NaturalId`. `mutable="true"` on `<natural-id>` maps to `@NaturalId(mutable=true)` on each field. If a `<cache>` element is associated with the natural ID in HBM (not shown), `@NaturalIdCache` might be added to the entity. `hbm2java` handles this. |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write" region="itemCache"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied, or explicitly if needed for provider) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region="itemCache")` | `<cache usage="..." region="..."/>` nested within a collection tag (like `<set>`, `<list>`, etc.) maps to Hibernate's `@Cache` annotation on the collection field. `usage` maps to `CacheConcurrencyStrategy`. |

---

## Other Mappings

Covers other tags like `<natural-id>`, `<cache>`, etc.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator column="ANIMAL_TYPE" type="string" length="20"/> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance (default when `<discriminator>` is present without `<joined-subclass>` or `<union-subclass>`). The `discriminator column` attribute maps to `@DiscriminatorColumn name`. The `type` attribute maps to `discriminatorType` (STRING, CHAR, INTEGER). `length` is also set. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator formula="CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END" type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | `@org.hibernate.annotations.DiscriminatorFormula("CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END")` | If `formula` is used on `<discriminator>`, it maps to Hibernate's `@DiscriminatorFormula`. `type` on discriminator still informs Hibernate about the expected type of the formula's result. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. This is mapped by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though direct mapping might occur if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity, or in a central place like `package-info.java`) |  | HQL query defined in CDATA section is mapped to the `query` attribute of `@NamedQuery`. `name` attribute is used for `name`. `hbm2java` typically adds these to the relevant entity class. |
| `<sql-query name="findUserWithAddress"> <return alias="user" class="com.example.User"/> <return-join alias="addr" property="user.address"/> <![CDATA[ SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ? ]]> </sql-query>` | `@NamedNativeQuery(name="findUserWithAddress", query="SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ?", resultSetMapping="userWithAddressMapping")` <br/> `@SqlResultSetMapping(name="userWithAddressMapping", entities={@EntityResult(entityClass=com.example.User.class, alias="user", fields={@FieldResult(name="address", column="addr")})})` (Note: `FieldResult` for `return-join` is simplified here; this might map `return-join` to a separate `@EntityResult` if `addr` is an entity, or handle it as part of the main `EntityResult`'s fields if the join populates a property of `user`.) |  | An SQL query maps to `@NamedNativeQuery`. `<return alias="..." class="..."/>` maps to `@EntityResult(entityClass=...)`. `<return-join property="user.address"/>` (populating a property of the main return) maps to `@FieldResult` within the main `@EntityResult`. A `resultSetMapping` name is generated. If the join returns another full entity, it would be a separate `@EntityResult`. |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <return-scalar column="user_age" type="integer"/> <![CDATA[ SELECT name AS user_name, age AS user_age FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name, age AS user_age FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name", type=String.class), @ColumnResult(name="user_age", type=Integer.class)})` |  | `<return-scalar column="..." type="..."/>` maps to `@ColumnResult(name="...", type=...)` within a `@SqlResultSetMapping`. `hbm2java` derives the Java type from HBM type. |
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber" column="EMP_NO"/> <many-to-one name="department" column="DEPT_ID"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId @Column(name="EMP_NO")` <br/> On `department` field: `@NaturalId @ManyToOne @JoinColumn(name="DEPT_ID")` | `@org.hibernate.annotations.NaturalIdCache` (on class `Employee`, if `<cache>` is also used for natural-id) | Properties within `<natural-id>` are annotated with `@NaturalId`. `mutable="true"` on `<natural-id>` maps to `@NaturalId(mutable=true)` on each field. If a `<cache>` element is associated with the natural ID in HBM (not shown), `@NaturalIdCache` might be added to the entity. `hbm2java` handles this. |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write" region="itemCache"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied, or explicitly if needed for provider) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region="itemCache")` | `<cache usage="..." region="..."/>` nested within a collection tag (like `<set>`, `<list>`, etc.) maps to Hibernate's `@Cache` annotation on the collection field. `usage` maps to `CacheConcurrencyStrategy`. |
