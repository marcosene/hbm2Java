# Hibernate 4 HBM to JPA/Hibernate Annotation Mapping Guide

This guide provides a mapping from Hibernate 4 HBM XML configurations to their corresponding JPA (Jakarta Persistence API) and Hibernate-specific annotations as generated by the `hbm2java` tool. Understanding these mappings can help in migrating from legacy HBM files to modern annotation-based configurations or in understanding the output of `hbm2java`.

## Table of Contents
- Global Mappings (`<hibernate-mapping>`)
- Class Mappings (`<class>`, `<subclass>`, `<union-subclass>`)
- Identifier Mappings (`<id>`, `<generator>`, `<param>`)
- Version Mappings (`<version>`)
- Property Mappings (`<property>`, `<column>`, `<type>`)
- Component Mappings (`<component>`, `<properties>`)
- Relationship Mappings (`<many-to-one>`, `<one-to-one>`)
- Collection Mappings (`<set>`, `<list>`, `<bag>`, `<map>`, `<key>`, `<one-to-many>`, `<many-to-many>`, `<list-index>`, `<map-key>`, `<composite-map-key>`, `<key-property>`)
- Inheritance Mappings (`<discriminator>`, `<join>`)
- Cache Mappings (`<cache>`)
- Natural ID Mappings (`<natural-id>`)
- Query Mappings (`<query>`, `<sql-query>`, `<return-scalar>`)

---

## Global Mappings (`<hibernate-mapping>`)

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<hibernate-mapping default-cascade="save-update">` | (No direct equivalent at package level) | (No direct annotation) | `HbmParser` reads `default-cascade` from the root `<hibernate-mapping>` element and stores it in `JpaEntity.defaultCascade`. This value is then used by `JpaRelationship.setCascade()` to determine default cascade behavior for relationships if not explicitly specified on the relationship itself. JPA cascades are defined per-relationship. |
<!-- schema, catalog, package attributes for hibernate-mapping are not read by HbmParser.java -->

---

## Class Mappings (`<class>`, `<subclass>`, `<union-subclass>`)

Covers core entity definition attributes from the `<class>`, `<subclass>`, and `<union-subclass>` tags. `HbmParser.java`'s `parseClasses` and `parseEntity` methods handle these.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="com.example.Foo">` | `@Entity` | | The `name` attribute (read by `parseEntity`) determines the FQCN. |
| `<class name="Foo" table="FOO_TABLE">` | `@Entity` <br/> `@Table(name="FOO_TABLE")` |  | `table` attribute (read by `parseEntity`) maps to `@Table(name=...)`. |
| `<class name="Foo" dynamic-update="true">` | `@Entity` | `@org.hibernate.annotations.DynamicUpdate` | `dynamic-update` attribute (read by `parseEntity`) maps to `@DynamicUpdate`. |
| `<class name="Foo" dynamic-insert="true">` | `@Entity` | `@org.hibernate.annotations.DynamicInsert` | `dynamic-insert` attribute (read by `parseEntity`) maps to `@DynamicInsert`. |
| `<class name="BaseFoo" abstract="true">` | `@MappedSuperclass` or <br/> `@Entity` (if it has persistent fields/table) | | `abstract="true"` (read by `parseEntity`) typically results in `@MappedSuperclass` if the class is intended as a non-entity base. If it has a table or persistent fields, it can be an abstract `@Entity`. `hbm2java` makes the Java class abstract. |
| `<class name="Foo" mutable="false">` | `@Entity` | `@org.hibernate.annotations.Immutable` | `mutable="false"` (read by `parseEntity`) maps to `@Immutable`. |
| `<class name="Foo" discriminator-value="F">` | `@Entity` <br/> `@DiscriminatorValue("F")` | | `discriminator-value` (read by `parseEntity` for `JpaDiscriminator`) is used in inheritance. |
| `<subclass name="com.example.Bar" extends="com.example.Foo">` | `@Entity` | | `name` and `extends` (read by `parseEntity` for subclasses) define the subclass relationship. |
| `<subclass name="Bar" table="BAR_TABLE">` | `@Entity` <br/> `@Table(name="BAR_TABLE")` (for JOINED) | | `table` attribute for `<subclass>` is used in JOINED strategy. Ignored for SINGLE_TABLE. |
| `<subclass name="Bar" discriminator-value="B">` | `@Entity` <br/> `@DiscriminatorValue("B")` | | `discriminator-value` for `<subclass>`. |
| `<union-subclass name="com.example.Baz" extends="com.example.Foo">` | `@Entity` | | `name` and `extends` for `<union-subclass>`. |
| `<union-subclass name="Baz" table="BAZ_TABLE">` | `@Entity` <br/> `@Table(name="BAZ_TABLE")` | | `table` for `<union-subclass>` specifies its dedicated table. |
<!-- Other attributes like 'schema', 'catalog', 'proxy', 'lazy', 'batch-size', 'select-before-update', 'optimistic-lock' for <class> are not explicitly parsed and used by HbmParser.java for JpaEntity model construction. -->

---

## Identifier Mappings (`<id>`, `<generator>`, `<param>`)

Covers primary key mappings. `<composite-id>` is not listed as implemented, so examples are focused on `<id>`.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<id name="id" type="long"/>` | `@Id` |  | `name` is field name. `type` determines Java field type (mapped via `HibernateUtils.mapHibernateTypeToJava`). `HbmParser` reads `name`, `type`, and `column` from `<id>`. |
| `<id name="id" column="ID_COL"/>` | `@Id` <br/> `@Column(name="ID_COL")` |  | `column` attribute on `<id>` maps to `@Column(name=...)`. |
| `<id name="id"> <column name="ID_COL_NESTED"/> </id>` | `@Id` <br/> `@Column(name="ID_COL_NESTED")` | | A nested `<column>` tag within `<id>` also defines the column name. `HbmParser`'s `parseIdAndGenerator` checks for this. |
| `<id name="id" type="long"> <generator class="identity"/> </id>` | `@Id` <br/> `@GeneratedValue(strategy=GenerationType.IDENTITY)` |  | `generator class="identity"` maps to `GenerationType.IDENTITY`. `HbmParser` processes common generator classes. |
| `<id name="id" type="long"> <generator class="sequence"> <param name="sequence_name">MY_SEQ</param> </generator> </id>` | `@Id` <br/> `@GeneratedValue(strategy=GenerationType.SEQUENCE, generator="mySeqGen")` <br/> `@SequenceGenerator(name="mySeqGen", sequenceName="MY_SEQ")` |  | `generator class="sequence"` maps to `GenerationType.SEQUENCE`. Nested `<param name="sequence_name">` becomes `sequenceName` in `@SequenceGenerator`. `HbmParser` reads params. |
| `<id name="id" type="long"> <generator class="native"/> </id>` | `@Id` <br/> `@GeneratedValue(strategy=GenerationType.AUTO)` |  | `generator class="native"` maps to `GenerationType.AUTO`. |
| `<id name="id" type="long"> <generator class="assigned"/> </id>` | `@Id` |  | `generator class="assigned"` means no `@GeneratedValue`. |
| `<id name="id" type="mypackage.MyCustomIdType"> <generator class="mypackage.MyCustomGenerator"/> </id>` | `@Id` <br/> `@GeneratedValue(generator="customGen")` | `@org.hibernate.annotations.GenericGenerator(name="customGen", strategy="mypackage.MyCustomGenerator")` | Custom generator `class` maps to `@GenericGenerator` strategy. `HbmParser` defaults to "GENERATOR" type and puts class as param if not a known one. |
<!-- The 'unsaved-value' attribute for <id> is not read by HbmParser.java. -->

---

## Version Mappings (`<version>`)

Covers optimistic locking versioning. `HbmParser.java`'s `parseVersions` method handles this, calling `parseColumns`.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<version name="version" type="integer"/>` | `@Version` |  | Maps to a field (e.g., `private Integer version;`) annotated with `@Version`. `name` and `type` are read from the `<version>` tag by `parseProperty` (called via `parseColumns`). |
| `<version name="timestamp" type="timestamp"> <column name="OBJ_VERSION"/> </version>` | `@Version` <br/> `@Column(name="OBJ_VERSION")` | | `name` and `type` from `<version>`. The column name "OBJ_VERSION" is taken from the nested `<column>` tag as processed by `parseColumns` and `parseColumn`. |
<!-- The 'column' attribute directly on <version> is not used by parseProperty for column name if a nested <column> is present. -->


---

## Property Mappings (`<property>`, `<column>`, `<type>`)

Covers basic property/attribute mappings.
This section also includes examples of how nested `<column>` and `<type>` elements within `<property>` are handled.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<property name="myField" type="string"/>` | `@Basic` (often implied) |  | `name` is field name. `type` determines Java field type. |
| `<property name="myField" column="MY_COL"/>` | `@Column(name="MY_COL")` |  | `column` attribute maps to `@Column(name=...)`. |
| `<property name="myField" length="100"/>` | `@Column(length=100)` |  | `length` attribute maps to `@Column(length=...)`. |
| `<property name="myField" update="false"/>` | `@Column(updatable=false)` |  | `update` attribute maps to `updatable=false`. |
| `<property name="lazyField" lazy="true"/>` | `@Basic(fetch=FetchType.LAZY)` |  | `lazy="true"` on a property maps to `@Basic(fetch=FetchType.LAZY)`. |
| `<property name="nonOptimisticField" optimistic-lock="false"/>` | (No direct equivalent) | `@org.hibernate.annotations.OptimisticLock(excluded=true)` | `optimistic-lock="false"` excludes the property from optimistic lock checks. |
| `<property name="myField"> <column name="MY_COL"/> </property>` | `@Column(name="MY_COL")` | | A nested `<column>` tag can define column attributes. |
| `<property name="myField"> <column name="MY_COL" length="100"/> </property>` | `@Column(name="MY_COL", length=100)` | | `length` on nested `<column>`. |
| `<property name="myField"> <column name="MY_COL" not-null="true"/> </property>` | `@Column(name="MY_COL", nullable=false)` | | `not-null="true"` on nested `<column>` maps to `nullable=false`. |
| `<property name="myField"> <column name="MY_COL" unique="true"/> </property>` | `@Column(name="MY_COL", unique=true)` | | `unique="true"` on nested `<column>`. |
| `<property name="myField"> <column name="MY_COL" index="MY_IDX"/> </property>` | `@Index(name="MY_IDX")` (on `@Table` or as part of `@TableGenerator`) | | `index` on nested `<column>` maps to `@Index`. `hbm2java` would add this to the `@Table` annotation of the entity or relevant join table. |
| `<property name="myField"> <column name="MY_COL" default="DEFAULT_VALUE"/> </property>` |  | `@org.hibernate.annotations.ColumnDefault("DEFAULT_VALUE")` | `default` on nested `<column>` maps to Hibernate's `@ColumnDefault`. |
| `<property name="myField"> <column name="MY_COL" unique-key="MY_UK"/> </property>` | `@Column(name="MY_COL", unique=true)` (JPA standard unique constraint) or part of `@Table(uniqueConstraints=...)` | | `unique-key` on nested `<column>` contributes to a unique constraint. Mapped to `@Table(uniqueConstraints=@UniqueConstraint(columnNames={"MY_COL"}, name="MY_UK"))`. |
| `<property name="myField"> <column name="MY_COL" sql-type="VARCHAR2(100)"/> </property>` | `@Column(name="MY_COL", columnDefinition="VARCHAR2(100)")` | | `sql-type` on nested `<column>` maps to `columnDefinition`. |
| `<property name="amount"> <column name="AMT" precision="10" scale="2"/> </property>` | `@Column(name="AMT", precision=10, scale=2)` | | `precision` and `scale` on nested `<column>`. |
| `<property name="status"> <type name="org.hibernate.type.EnumType"> <param name="enumClass">com.example.StatusEnum</param> <param name="useNamed">true</param> </type> </property>` | `@Enumerated(EnumType.STRING)` (if `useNamed` is true and `param name="enumClass"` present) or <br/> `@Enumerated(EnumType.ORDINAL)` (if `useNamed` is false or not present, and `param name="enumClass"` present) | `@org.hibernate.annotations.Type(type = "org.hibernate.type.EnumType", parameters = { @org.hibernate.annotations.Parameter(name="enumClass", value="com.example.StatusEnum"), @org.hibernate.annotations.Parameter(name="useNamed", value="true") })` (If JPA `@Enumerated` is not sufficient) | Nested `<type name="..."/>` allows specifying a Hibernate type. `hbm2java` tries to map to standard JPA annotations first. Only `name` attribute is implemented for `<type>` and `<param>`. |
| `<property name="customTypeField"> <type name="com.example.MyCustomUserType"/> </property>` |  | `@org.hibernate.annotations.Type(type = "com.example.MyCustomUserType")` | When a specific `UserType` is defined via nested `<type name="..."/>`, it maps to Hibernate's `@Type`. `HbmParser`'s `parseProperty` method reads the `name` attribute of the `<type>` tag and any nested `<param>` elements. |
| `<property name="amount" type="com.example.VirtualCurrencyQuantityUserType"> <column name="AMOUNT_VC"/> <column name="AMOUNT_AMOUNT"/> </property>` | Conceptual JPA: <br/> `@Embedded` <br/> `@AttributeOverrides({@AttributeOverride(name="vcField", column=@Column(name="AMOUNT_VC")), @AttributeOverride(name="amountField", column=@Column(name="AMOUNT_AMOUNT"))})` <br/> `private com.example.VirtualCurrencyQuantity amount;` <br/> --- OR if UserType handles multiple columns --- <br/> `@Type(type="com.example.VirtualCurrencyQuantityUserType")` <br/> `@Columns(columns={@org.hibernate.annotations.Column(name="AMOUNT_VC"), @org.hibernate.annotations.Column(name="AMOUNT_AMOUNT")})` <br/> `private com.example.VirtualCurrencyQuantity amount;` | `@org.hibernate.annotations.Columns` is Hibernate-specific. Placeholder field names "vcField", "amountField" used for `@AttributeOverride` example. | `HbmParser` (`parsePropertyList` calling `parseColumns`) processes a `<property>` with multiple direct `<column>` children into a `JpaCompositeColumn`. This `JpaCompositeColumn` stores the property's `name` (e.g., "amount") and `type` (e.g., "com.example.VirtualCurrencyQuantityUserType"), and a list of `JpaColumn` objects for "AMOUNT_VC" and "AMOUNT_AMOUNT". <br/> If `com.example.VirtualCurrencyQuantityUserType` refers to an `@Embeddable` class, the typical JPA output uses `@Embedded` and `@AttributeOverrides`. The `name` attributes in `@AttributeOverride` must match the field names within the embeddable class. <br/> If it's a Hibernate UserType that handles multiple columns, `@Type` (from Hibernate) with `@Columns` would be used. |

---

## Component Mappings (`<component>`, `<properties>`)

Covers embedded object mappings using `<component>`. The `<properties>` tag is for grouping properties, often within a component or a named property group.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<component name="address" class="com.example.Address"> <property name="street"/> </component>` | `@Embedded` <br/> `private com.example.Address address;` <br/> --- <br/> `@Embeddable` <br/> `public class Address { private String street; ... }` |  | `HbmParser.parseComponents` reads `name` and `class` for the component. Nested `<property>` elements are parsed by `parsePropertyList`. The `class` becomes an `@Embeddable` Java class. |
| `<class name="User"> ... <properties name="nameDetails" unique="true"> <property name="firstName"/> <property name="lastName"/> </properties> </class>` |  If `nameDetails` implies a new Embeddable: <br/> `@Embedded private NameDetails nameDetails;` <br/> --- <br/> `@Embeddable public class NameDetails { ... @Column(unique=true) private String firstName; ...}` <br/> OR (if unique constraint on owning table): <br/> `@Table(uniqueConstraints=@UniqueConstraint(name="nameDetails_UK", columnNames={"firstName_col", "lastName_col"}))`| | `HbmParser.parseProperties` reads `name` and `unique`. If `unique="true"`, this `name` is used to form a unique constraint name for properties parsed within. The tool might generate a separate `@Embeddable` class for the properties group or map them directly on the entity, applying uniqueness as feasible. |
<!-- HbmParser.java does not read 'access' for component, nor 'insert', 'update', 'optimistic-lock', 'node', 'embed-xml' which are other attributes sometimes associated with <component>. -->
<!-- For <properties>, 'node', 'insert', 'update', 'optimistic-lock' are not read by HbmParser.java. -->

---

## Relationship Mappings (`<many-to-one>`, `<one-to-one>`)

Covers `<many-to-one>` and `<one-to-one>` mappings.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<many-to-one name="user" class="com.example.User"/>` | `@ManyToOne` |  | `name` is field name, `class` is target entity. `HbmParser`'s `parseRelationship` method defaults its internal `fetch` representation to "eager". Since `FetchType.EAGER` is the JPA default for `@ManyToOne`, the `fetch=FetchType.EAGER` attribute is often omitted in the final generated JPA code. |
| `<many-to-one name="user" column="USER_ID"/>` | `@ManyToOne` <br/> `@JoinColumn(name="USER_ID")` |  | `column` attribute maps to `@JoinColumn(name=...)`. |
| `<many-to-one name="user" cascade="save-update,delete"/>` | `@ManyToOne(cascade={CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE})` |  | `cascade` values are processed by `HbmParser`'s `setCascade` method. "save-update" maps to PERSIST and MERGE. |
| `<many-to-one name="user" fetch="join"/>` | `@ManyToOne(fetch=FetchType.EAGER)` |  | `fetch="join"` explicitly sets EAGER fetching. `HbmParser` reads this attribute. This will result in `fetch=FetchType.EAGER` in JPA. |
| `<many-to-one name="user" fetch="select"/>` | `@ManyToOne(fetch=FetchType.LAZY)` |  | `HbmParser` reads `fetch="select"`. For `@ManyToOne`, this implies LAZY fetching unless `lazy="false"`. Since JPA's default for `@ManyToOne` is EAGER, `fetch=FetchType.LAZY` will be generated. |
| `<many-to-one name="user" lazy="proxy"/>` | `@ManyToOne(fetch=FetchType.LAZY)` | | `lazy="proxy"` (or `lazy="true"`) implies LAZY fetching. `HbmParser` processes this. This generates `fetch=FetchType.LAZY` in JPA as it overrides the JPA default (EAGER). |
| `<many-to-one name="user" lazy="false"/>` | `@ManyToOne` | | `lazy="false"` implies EAGER. As this is the JPA default for `@ManyToOne`, the `fetch=FetchType.EAGER` attribute is often omitted in generated JPA. |
| `<many-to-one name="user" not-null="true"/>` | `@ManyToOne` <br/> `@JoinColumn(nullable=false)` |  | `not-null="true"` maps to `nullable=false` on `@JoinColumn`. |
| `<many-to-one name="user" unique="true"/>` | `@ManyToOne` <br/> `@JoinColumn(unique=true)` |  | `unique="true"` maps to `unique=true` on `@JoinColumn`. |
| `<many-to-one name="user" foreign-key="FK_USER_ORDER"/>` | `@ManyToOne` <br/> `@JoinColumn(foreignKey=@ForeignKey(name="FK_USER_ORDER"))` |  | `foreign-key` attribute specifies a custom FK constraint name. |
| `<many-to-one name="user" property-ref="userCode"/>` | `@ManyToOne` <br/> `@JoinColumn(referencedColumnName="userCode")` |  | `property-ref` maps the FK to a non-PK column on the target entity. Must be unique. |
| `<many-to-one name="user" access="field"/>` | `@ManyToOne` <br/> `@Access(AccessType.FIELD)` | | `access="field"` forces field access. |
| `<many-to-one name="user" index="IDX_USER"/>` | `@ManyToOne` <br/> `@JoinColumn(name="USER_ID")` (index applied via `@Table`) | | The `index` attribute on `many-to-one` suggests an index on the foreign key column. `hbm2java` would typically add an `@Index` annotation to the `@Table` definition for the column specified in `@JoinColumn`. |
| `<one-to-one name="profile" class="com.example.Profile"/>` | `@OneToOne` |  | `name` and `class` as usual. |
| `<one-to-one name="profile" cascade="all"/>` | `@OneToOne(cascade=CascadeType.ALL)` |  | `cascade` maps similarly to many-to-one. |
| `<one-to-one name="profile" constrained="true"/>` | `@OneToOne` <br/> `@MapsId` (if FK is also PK) or <br/> `@PrimaryKeyJoinColumn` |  | `constrained="true"` implies shared PK. `hbm2java` might use `@MapsId` or `@PrimaryKeyJoinColumn`. |
| `<one-to-one name="address" property-ref="person"/>` | `@OneToOne(mappedBy="person")` (if `person` is owner field in `Address`) or <br/> `@JoinColumn(referencedColumnName="person")` (if this side is owner and FK refers to non-PK 'person' field in Address) |  | If `property-ref` indicates the mappedBy property on the target, `mappedBy` is used. If it refers to a non-PK column on the target for joining, `referencedColumnName` is used. |
<!-- Removed update="false" for relationships as it's not commonly used directly on the relation annotation itself but rather on the JoinColumn if it's part of an Embeddable or specific cases. The "update" attribute is listed for relationship tags, but its JPA mapping can be nuanced. For now, focusing on more direct mappings. -->

---

## Collection Mappings (`<set>`, `<list>`, `<bag>`, `<map>`, `<key>`, `<one-to-many>`, `<many-to-many>`, `<list-index>`, `<map-key>`, `<composite-map-key>`, `<key-property>`)

Covers various collection types and their specific elements.

**General Collection Attributes & Concepts:**

| HBM Attribute       | Typical JPA/Hibernate Annotation/Concept                                     | Notes                                                                                                                                                                                             |
| :------------------ | :--------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `name`              | Field name in the entity.                                                    | The name of the Java property holding the collection.                                                                                                                                             |
| `table`             | `@JoinTable(name="...")` (for ManyToMany, or OneToMany with join table), <br/> `@CollectionTable(name="...")` (for ElementCollection) | Specifies the name of the join table or collection table. `HbmParser` reads this in `parseCollection`.                                                                                                                                         |
| `lazy`              | `fetch` attribute in `@OneToMany`, `@ManyToMany`, `@ElementCollection`.      | HBM's default for collections is `lazy="true"`. `HbmParser` reads `lazy` in `parseCollection`. JPA's default for `@OneToMany` and `@ManyToMany` is `FetchType.LAZY`. If `lazy="true"` (or omitted) in HBM, the generated JPA `fetch=FetchType.LAZY` attribute is often omitted as it's the default. `lazy="extra"` is a Hibernate-specific option, potentially mapping to `@LazyCollection(LazyCollectionOption.EXTRA)`. |
| `fetch`             | `@org.hibernate.annotations.Fetch(FetchMode.SELECT/JOIN/SUBSELECT)`          | `fetch="select"` is the HBM default if not specified. `fetch="join"` implies EAGER fetching. `fetch="subselect"` is a Hibernate optimization for LAZY fetching. `HbmParser` reads `fetch` in `parseCollection`. If the HBM `fetch` strategy (combined with `lazy`) results in a JPA default (e.g., LAZY for `@OneToMany`), the `fetch` attribute might be omitted in the generated JPA. |
| `cascade`           | `cascade` attribute in `@OneToMany`, `@ManyToMany`, `@ElementCollection`.      | HBM cascade options (e.g., "all", "save-update", "delete") map to `CascadeType` values (e.g., `ALL`, `PERSIST`, `MERGE`, `REMOVE`). `delete-orphan` is separate (`orphanRemoval=true`). |
| `inverse="true"`    | `mappedBy="..."` attribute in `@OneToMany`, `@ManyToMany`.                     | Indicates the collection is the inverse (non-owning) side of a bidirectional relationship. The `mappedBy` value is the name of the property on the owning side.                                        |
| `order-by`          | `@OrderBy("column_name asc/desc, ...")`                                      | For collections of entities, specifies a DB-level ordering. `column_name` refers to a column in the target entity's table.                                                                       |

**The `<key>` Element:**

| HBM Attribute (`<key>`) | JPA Annotation(s)                                                                 | Notes                                                                                                                               |
| :---------------------- | :-------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------- |
| `column`                | `@JoinColumn(name="...")` (within `@JoinTable` or directly on collection attribute) | Specifies the foreign key column name in the collection/join table or child table.                                                       |
| `foreign-key`           | `@JoinColumn(foreignKey=@ForeignKey(name="..."))`                                 | Specifies a custom name for the foreign key constraint.                                                                             |

---
**Specific Collection Tag Mappings:**

| HBM XML Snippet (General Attributes)                                       | JPA Annotation(s) & Collection Type                                                                                                | Hibernate Annotation(s) (if needed) | Notes                                                                                                                                                                                                                                                           |
| :------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `<set name="items"> <key column="OWNER_ID"/> <one-to-many class="Item"/> </set>` | `private java.util.Set<Item> items;` <br/> `@OneToMany` <br/> (`@JoinColumn(name="OWNER_ID")` if unidirectional) | | Maps to `java.util.Set`. `<key column="..."/>` indicates FK. `HbmParser` (`parseCollection`) considers `lazy` (default "true") and `fetch`. Since `@OneToMany` is LAZY by default in JPA, if HBM implies LAZY (e.g. `lazy="true"` or default), `fetch=FetchType.LAZY` is often omitted in generated JPA. |
| `<set name="items" table="ITEM_SET_TABLE"> <key column="OWNER_ID"/> <many-to-many class="Item" column="ITEM_ID"/> </set>` | `private java.util.Set<Item> items;` <br/> `@ManyToMany` <br/> `@JoinTable(name="ITEM_SET_TABLE", joinColumns=@JoinColumn(name="OWNER_ID"), inverseJoinColumns=@JoinColumn(name="ITEM_ID"))` | | `table` attribute specifies join table for `@ManyToMany`. `@ManyToMany` is LAZY by default in JPA. If HBM implies LAZY, `fetch=FetchType.LAZY` is often omitted in generated JPA. |
| `<set name="items" lazy="false"> <one-to-many class="Item"/> </set>` | `... @OneToMany(fetch=FetchType.EAGER)` | | `lazy="false"` explicitly sets EAGER fetching. Generated JPA will include `fetch=FetchType.EAGER` as this overrides the JPA default (LAZY for `@OneToMany`). |
| `<set name="items" fetch="join"> <one-to-many class="Item"/> </set>` | `... @OneToMany(fetch=FetchType.EAGER)` | `@org.hibernate.annotations.Fetch(FetchMode.JOIN)` | `fetch="join"` implies EAGER. `HbmParser` reads this. Generated JPA will include `fetch=FetchType.EAGER`. |
| `<set name="items" cascade="all"> ... </set>` | `... @OneToMany(cascade=CascadeType.ALL)` or <br/> `... @ManyToMany(cascade=CascadeType.ALL)` | | `cascade="all"` maps to `CascadeType.ALL`. |
| `<set name="items" inverse="true"> ... </set>` | `... @OneToMany(mappedBy="ownerProperty")` or <br/> `... @ManyToMany(mappedBy="ownerProperty")` | | `inverse="true"` maps to `mappedBy`. |
| `<set name="items" order-by="name asc"> ... </set>` | `... @OrderBy("name asc")` | | `order-by` attribute for DB-level ordering. |
| `<list name="tasks"> <key column="TODO_ID"/> <list-index column="TASK_IDX"/> ... </list>` | `private java.util.List<Task> tasks;` <br/> `@OneToMany` or `@ManyToMany` <br/> `@OrderColumn(name="TASK_IDX")` | | `hbm2java` maps `<list>` to `java.util.List`. `<list-index column="..."/>` adds `@OrderColumn`. |
| `<bag name="events"> <key column="EVENT_OWNER_ID"/> ... </bag>` | `private java.util.Collection<Event> events;` <br/> `@OneToMany` or `@ManyToMany` | | `hbm2java` typically maps `<bag>` to `java.util.Collection` or `java.util.List`. |
| `<map name="attributes"> <key column="ENTITY_ID"/> <map-key column="ATTR_NAME" type="string"/> <element column="ATTR_VALUE" type="string"/> </map>` | `private java.util.Map<String, String> attributes;` <br/> `@ElementCollection` <br/> `@CollectionTable(joinColumns=@JoinColumn(name="ENTITY_ID"))` <br/> `@MapKeyColumn(name="ATTR_NAME")` <br/> `@Column(name="ATTR_VALUE")` |  | `hbm2java` maps `<map>` to `java.util.Map`. `<map-key column="..." type="..."/>` maps to `@MapKeyColumn`. `<element column="..." type="..."/>` maps the value. |

---
**Collection Element Mappings:**

This table details the mapping of elements *within* collection tags like `<set>`, `<list>`, `<bag>`, and `<map>`.
The `column` attribute on `<element>` and `<many-to-many>` is specific to those tags when used inside collections, and not the general `<column>` tag listed in "Implemented Tags".

| HBM XML Snippet (Nested Element)                                                                                                | JPA Annotation(s) on Collection Field / Related Annotations                                                                                                                                                                                                                                                              | Notes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| :------------------------------------------------------------------------------------------------------------------------------ | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`<element>` (Basic Type)** <br/> `<set name="aliases"> <key column="ENTITY_ID"/> <element column="alias_name" type="string"/> </set>`                               | `java.util.Set<String> aliases;` <br/> `@ElementCollection` <br/> `@CollectionTable(name="ENTITY_ALIASES", joinColumns=@JoinColumn(name="ENTITY_ID"))` <br/> `@Column(name="alias_name")` | `<element type="string"/>` maps to a collection of basic types using `@ElementCollection`. The `column="alias_name"` on `<element>` defines the column for these types. The `type` attribute on `<element>` is used by `hbm2java` to determine the Java collection's generic type and the database column type, but `<element>` itself doesn't have a `type` attribute in the provided implemented list. This example assumes `type` on `element` is implicitly handled or refers to the `type` tag used elsewhere. The primary focus here is `column` on `<element>`. |
| **`<one-to-many>` (Nested)** <br/> `<set name="phones"> <key column="OWNER_ID"/> <one-to-many class="com.example.Phone"/> </set>`                                                | `java.util.Set<Phone> phones;` <br/> `@OneToMany` <br/> (`@JoinColumn(name="OWNER_ID")` if unidirectional) or <br/> (`mappedBy="ownerPropertyInPhone"` if bidirectional) | `<one-to-many class="..."/>` defines the target entity. `HbmParser` handles this. Default fetch for `@OneToMany` is LAZY. If the collection's HBM attributes (like `lazy="true"`, which is default for collections) result in LAZY fetch, the generated JPA `@OneToMany` might omit `fetch=FetchType.LAZY` as it's the JPA default. |
| **`<many-to-many>` (Nested)** <br/> `<set name="courses" table="STUDENT_COURSES"> <key column="STUDENT_ID"/> <many-to-many class="com.example.Course" column="COURSE_ID"/> </set>` | `java.util.Set<Course> courses;` <br/> `@ManyToMany` <br/> `@JoinTable(name="STUDENT_COURSES", joinColumns=@JoinColumn(name="STUDENT_ID"), inverseJoinColumns=@JoinColumn(name="COURSE_ID"))` | `<many-to-many class="..." column="..."/>` maps to `@ManyToMany`. `table` from parent collection tag is used for `@JoinTable(name=...)`. `<key column="..."/>` defines `joinColumns`. `column` on `<many-to-many>` defines `inverseJoinColumns`. Default fetch for `@ManyToMany` is LAZY. If the collection's HBM attributes result in LAZY fetch, the generated JPA might omit `fetch=FetchType.LAZY`. |
| **`<many-to-many>` (with `foreign-key`)** <br/> `<set name="roles" table="USER_ROLES"> <key column="USER_ID"/> <many-to-many class="Role" column="ROLE_ID" foreign-key="FK_ROLE_IN_JT"/> </set>` | `java.util.Set<Role> roles;` <br/> `@ManyToMany` <br/> `@JoinTable(name="USER_ROLES", joinColumns=@JoinColumn(name="USER_ID"), inverseJoinColumns=@JoinColumn(name="ROLE_ID", foreignKey=@ForeignKey(name="FK_ROLE_IN_JT")))` | `foreign-key` on `<many-to-many>` applies to the `inverseJoinColumns`'s FK constraint. |
| **`<list-index>` (for `<list>`)** <br/> `<list name="chapters"> <key column="BOOK_ID"/> <list-index column="chapter_num"/> <one-to-many class="Chapter"/> </list>`       | `java.util.List<Chapter> chapters;` <br/> `@OneToMany(...)` <br/> `@OrderColumn(name="chapter_num")`                                                                                                                                                                                                | `<list-index column="..."/>` inside a `<list>` adds `@OrderColumn(name="...")` to maintain list order. |
| **`<map-key>` (Basic Type for `<map>`)** <br/> `<map name="systemSettings" table="SETTINGS"> <key column="USER_ID"/> <map-key column="SETTING_NAME" type="string"/> <element column="SETTING_VALUE" type="string"/> </map>` | `java.util.Map<String, String> systemSettings;` <br/> `@ElementCollection` <br/> `@CollectionTable(name="SETTINGS", joinColumns=@JoinColumn(name="USER_ID"))` <br/> `@MapKeyColumn(name="SETTING_NAME")` <br/> `@Column(name="SETTING_VALUE")` | `<map-key column="..." type="..."/>` defines mapping for a basic type map key. `type` attribute informs the Java type of the key. |
| **`<composite-map-key>` (Embeddable for `<map>`)** <br/> `<map name="customReports" table="USER_REPORTS"> <key column="USER_ID"/> <composite-map-key class="com.example.ReportKey"> <key-property name="reportName" column="REP_NAME" type="string"/> <key-property name="reportVersion" column="REP_VER" type="integer"/> </composite-map-key> <one-to-many class="com.example.ReportData"/> </map>` | `java.util.Map<ReportKey, ReportData> customReports;` <br/> `@OneToMany` <br/> `@MapKeyClass(ReportKey.class)` <br/> `// In ReportKey (@Embeddable):` <br/> `// @Column(name="REP_NAME") private String reportName;` <br/> `// @Column(name="REP_VER") private Integer reportVersion;` | `com.example.ReportKey` must be an `@Embeddable` class. `<composite-map-key class="..."/>` maps to `@MapKeyClass`. `<key-property name="..." column="..." type="..."/>` define fields in the `ReportKey` embeddable class. |
<!-- Removed <element class="..."> (embeddable element) as it's not explicitly listed and trying to keep examples focused on implemented attributes. -->

---

## Inheritance Mappings (`<discriminator>`, `<join>`)

Covers inheritance strategies. `<subclass>` and `<union-subclass>` are primarily handled in the "Class Mappings" section. This section focuses on elements that define the inheritance strategy itself (`<discriminator>`) and additional tables for joined inheritance (`<join>`).

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal"> <id name="id"/> <discriminator type="string"/> ... </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` <br/> `@DiscriminatorColumn(discriminatorType=DiscriminatorType.STRING)` |  | For `SINGLE_TABLE` inheritance. `HbmParser`'s `parseDiscriminator` reads the `type` attribute. If a nested `<column>` is not present, the discriminator column name defaults to "DTYPE" and length is not set. The `formula` attribute for `<discriminator>` is not processed by `HbmParser.java`. |
| `<class name="Animal"> <id name="id"/> <discriminator type="integer"> <column name="ANIMAL_TYPE" length="4"/> </discriminator> ... </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` <br/> `@DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.INTEGER, length=4)` |  | `type` on `<discriminator>` maps to `discriminatorType`. `HbmParser`'s `parseDiscriminator` method reads `name` and `length` from the nested `<column>` tag for the discriminator. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. `table` attribute on `<joined-subclass>` is handled by `@Table` on subclass. `HbmParser` processes this within `parseClasses` and `parseEntity`.|
| `<class name="Foo" table="MAIN_FOO"> ... <join table="JOIN_FOO"> <key column="FOO_ID"/> <property name="joinedProp"/> </join> ... </class>` | `@SecondaryTable(name="JOIN_FOO", pkJoinColumns=@PrimaryKeyJoinColumn(name="FOO_ID"))` (on class `Foo`) <br/> `@Column(table="JOIN_FOO")` (on `joinedProp` field) |  | `HbmParser`'s `parseEntity` method handles the `<join>` tag. The `table` attribute of `<join>` specifies the secondary table name. The nested `<key column="..."/>` (parsed by `parseKey`) defines the `@PrimaryKeyJoinColumn`. Properties within the `<join>` block are mapped to this secondary table. |
<!-- Union-subclass is covered in Class Mappings. -->

---

## Cache Mappings (`<cache>`)

Covers entity and collection caching.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Foo"> <cache usage="read-only"/> ... </class>` | `@Cacheable` (often implied by JPA provider if L2 cache enabled) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_ONLY)` | `HbmParser.parseEntity` reads the `usage` attribute from a `<cache>` element directly under `<class>`. The `region` attribute is not read by `HbmParser.java`. |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)` | `HbmParser.parseCollection` reads the `usage` attribute from a `<cache>` element nested within a collection tag. The `region` attribute is not read by `HbmParser.java`. |
<!-- Other <cache> attributes like 'include' are not read by HbmParser.java -->
---

## Natural ID Mappings (`<natural-id>`)

Covers mapping of natural business keys. `HbmParser.java`'s `parseNaturalIds` method handles this.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId` | If `mutable="true"`: `@org.hibernate.annotations.NaturalId(mutable=true)` <br/> Else (default `mutable="false"`): `@org.hibernate.annotations.NaturalId(mutable=false)` (or just `@NaturalId`) | `HbmParser.parseNaturalIds` reads the `mutable` attribute. Nested `<property>` and `<many-to-one>` elements are parsed to become part of the natural ID. |
<!-- HbmParser.java does not seem to parse a nested <cache> element specifically for <natural-id>. Entity/collection caching handles general caching. -->

---

## Query Mappings (`<query>`, `<sql-query>`, `<return-scalar>`)

Covers named HQL and SQL queries. `HbmParser.java`'s `parseQueries` and `parseQueryReturnColumns` methods handle these.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity or in `package-info.java`) |  | `HbmParser.parseQueries` reads the `name` attribute and the CDATA content for the HQL query. |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <![CDATA[ SELECT name AS user_name FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name")})` |  | `HbmParser.parseQueries` reads `name` and CDATA for the SQL. `parseQueryReturnColumns` processes nested `<return-scalar>`, reading `column` and `type` attributes. The `type` on `@ColumnResult` can be set if `hbm2java` maps the HBM type. |
<!-- HbmParser.parseQueryReturnColumns only handles <return-scalar>. Other <sql-query> children like <return alias="..." class="..."> or <return-join...> are not processed by this method to populate JpaNamedQuery.returnColumns. -->
<!-- Attributes for <query> and <sql-query> like 'cacheable', 'cache-region', 'fetch-size', 'timeout', 'read-only', 'callable', 'comment' are not read by HbmParser.java. -->

---
<!-- Removed "Other Mappings" section as its content has been distributed or removed based on implemented features. -->
<!-- Persister, filter-def, filter, optimistic-lock attribute on class are not implemented. -->

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator type="string"><column name="ANIMAL_TYPE" length="20"/></discriminator> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance. `type` on `<discriminator>` maps to `discriminatorType`. Attributes like `name` (for column name) and `length` are specified on a nested `<column>` tag within `<discriminator>` and map to `@DiscriminatorColumn`. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | | `type` on discriminator informs Hibernate about the expected type. If a formula was used, it's not a standard JPA feature and would be handled by Hibernate-specific annotations if `hbm2java` supports its conversion. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. `hbm2java` maps this by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though `hbm2java` might map them directly if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |

---

## Relationship Mappings

Covers `<many-to-one>` and `<one-to-one>` mappings.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator column="ANIMAL_TYPE" type="string" length="20"/> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance (default when `<discriminator>` is present without `<joined-subclass>` or `<union-subclass>`). `discriminator column` maps to `@DiscriminatorColumn name`. `type` maps to `discriminatorType` (STRING, CHAR, INTEGER). `length` is also set. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator formula="CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END" type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | `@org.hibernate.annotations.DiscriminatorFormula("CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END")` | If `formula` is used on `<discriminator>`, it maps to Hibernate's `@DiscriminatorFormula`. `type` on discriminator still informs Hibernate about the expected type of the formula's result. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. `hbm2java` maps this by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though `hbm2java` might map them directly if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity, or in a central place like `package-info.java`) |  | HQL query defined in CDATA section is mapped to the `query` attribute of `@NamedQuery`. `name` attribute is used for `name`. `hbm2java` typically adds these to the relevant entity class. |
| `<sql-query name="findUserWithAddress"> <return alias="user" class="com.example.User"/> <return-join alias="addr" property="user.address"/> <![CDATA[ SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ? ]]> </sql-query>` | `@NamedNativeQuery(name="findUserWithAddress", query="SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ?", resultSetMapping="userWithAddressMapping")` <br/> `@SqlResultSetMapping(name="userWithAddressMapping", entities={@EntityResult(entityClass=com.example.User.class, alias="user", fields={@FieldResult(name="address", column="addr")})})` (Note: `FieldResult` for `return-join` is simplified here; `hbm2java` might map `return-join` to a separate `@EntityResult` if `addr` is an entity, or handle it as part of the main `EntityResult`'s fields if the join is to populate a property of `user`.) |  | SQL query maps to `@NamedNativeQuery`. `<return alias="..." class="..."/>` maps to `@EntityResult(entityClass=...)`. `<return-join property="user.address"/>` (populating a property of the main return) maps to `@FieldResult` within the main `@EntityResult`. A `resultSetMapping` name is generated. If the join returns another full entity, it would be a separate `@EntityResult`. |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <return-scalar column="user_age" type="integer"/> <![CDATA[ SELECT name AS user_name, age AS user_age FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name, age AS user_age FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name", type=String.class), @ColumnResult(name="user_age", type=Integer.class)})` |  | `<return-scalar column="..." type="..."/>` maps to `@ColumnResult(name="...", type=...)` within a `@SqlResultSetMapping`. `hbm2java` derives the Java type from HBM type. |
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber" column="EMP_NO"/> <many-to-one name="department" column="DEPT_ID"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId @Column(name="EMP_NO")` <br/> On `department` field: `@NaturalId @ManyToOne @JoinColumn(name="DEPT_ID")` | `@org.hibernate.annotations.NaturalIdCache` (on class `Employee`, if `<cache>` is also used for natural-id) | Properties within `<natural-id>` are annotated with `@NaturalId`. `mutable="true"` on `<natural-id>` maps to `@NaturalId(mutable=true)` on each field. If a `<cache>` element is associated with the natural ID in HBM (not shown), `@NaturalIdCache` might be added to the entity. `hbm2java` handles this. |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied, or explicitly if needed for provider) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)` | `<cache usage="..."/>` nested within a collection tag (like `<set>`, `<list>`, etc.) maps to Hibernate's `@Cache` annotation on the collection field. `usage` maps to `CacheConcurrencyStrategy`. `region` is a separate attribute on Hibernate's `@Cache`. |

---

## Collection Mappings

Covers various collection types like `<set>`, `<list>`, `<map>`, etc., including `<one-to-many>` and `<many-to-many>` within them.

**General Collection Attributes & Concepts:**

Many attributes are common across different collection mapping tags (`<set>`, `<list>`, `<bag>`, `<map>`). These are generally translated as follows:

| HBM Attribute       | Typical JPA/Hibernate Annotation/Concept                                     | Notes                                                                                                                                                                                             |
| :------------------ | :--------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `name`              | Field name in the entity.                                                    | The name of the Java property holding the collection.                                                                                                                                             |
| `table`             | `@JoinTable(name="...")` (for ManyToMany, or OneToMany with join table), `@CollectionTable(name="...")` (for ElementCollection) | Specifies the name of the join table or collection table.                                                                                                                                         |
| `lazy`              | `fetch` attribute in `@OneToMany`, `@ManyToMany`, `@ElementCollection`.      | `lazy="true"` (default) maps to `FetchType.LAZY`. `lazy="false"` maps to `FetchType.EAGER`. `lazy="extra"` maps to `FetchType.LAZY` and enables Hibernate's "extra-lazy" behavior (e.g., `size()` doesn't load all elements). `hbm2java` may use `@LazyCollection(LazyCollectionOption.EXTRA)` for "extra". |
| `fetch`             | `@org.hibernate.annotations.Fetch(FetchMode.SELECT/JOIN/SUBSELECT)`          | `fetch="select"` (default) is standard lazy/eager loading. `fetch="join"` implies EAGER with a join. `fetch="subselect"` uses a subselect to fetch collections for multiple parent entities.         |
| `cascade`           | `cascade` attribute in `@OneToMany`, `@ManyToMany`, `@ElementCollection`.      | HBM cascade options (e.g., "all", "save-update", "delete", "delete-orphan") map to `CascadeType` values (e.g., `ALL`, `PERSIST`, `MERGE`, `REMOVE`, `DETACH`, `REFRESH`). `delete-orphan` maps to `orphanRemoval=true`. |
| `inverse="true"`    | `mappedBy="..."` attribute in `@OneToMany`, `@ManyToMany`.                     | Indicates the collection is the inverse (non-owning) side of a bidirectional relationship. The `mappedBy` value is the name of the property on the owning side.                                        |
| `order-by`          | `@OrderBy("column_name asc/desc, ...")`                                      | For collections of entities, specifies a DB-level ordering. `column_name` refers to a column in the target entity's table.                                                                       |

**The `<key>` Element:**

The `<key>` element within a collection mapping is crucial for defining the foreign key in the collection table (for `@ElementCollection` or join tables in `@ManyToMany`/`@OneToMany`) or in the child table (for `@OneToMany` without a join table) that refers back to the owning entity's primary key.

| HBM Attribute (`<key>`) | JPA Annotation(s)                                                                 | Notes                                                                                                                               |
| :---------------------- | :-------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------- |
| `column`                | `@JoinColumn(name="...")` (within `@JoinTable` or directly on collection attribute) | Specifies the foreign key column name in the collection/join table or child table.                                                       |
| `foreign-key`           | `@JoinColumn(foreignKey=@ForeignKey(name="..."))`                                 | Specifies a custom name for the foreign key constraint.                                                                             |

---
**Specific Collection Tag Mappings:**

| HBM XML Snippet (General Attributes)                                       | JPA Annotation(s) & Collection Type                                                                                                | Hibernate Annotation(s) (if needed) | Notes                                                                                                                                                                                                                                                           |
| :------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `<set name="items" table="ITEM_SET_TABLE" lazy="true" fetch="select" cascade="all" inverse="false" order-by="name asc"> <key column="OWNER_ID"/> ... </set>` | `private java.util.Set<Item> items;` <br/> `@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.LAZY)` or `@ManyToMany(...)` <br/> `@JoinTable(name="ITEM_SET_TABLE", joinColumns=@JoinColumn(name="OWNER_ID"))` (if join table used) <br/> `@OrderBy("name asc")` | `@org.hibernate.annotations.Fetch(FetchMode.SELECT)` | `hbm2java` maps `<set>` to `java.util.Set`. Attributes like `table`, `lazy`, `fetch`, `cascade`, `inverse`, `order-by` are applied as shown. `<key>` maps to `@JoinColumn`. Specific content of set (e.g. `<element>`, `<one-to-many>`) determines full mapping. |
| `<list name="tasks" table="TASK_LIST_TABLE" cascade="persist" lazy="extra"> <key column="TODO_ID"/> ... </list>` | `private java.util.List<Task> tasks;` <br/> `@OneToMany(cascade=CascadeType.PERSIST, fetch=FetchType.LAZY)` or `@ManyToMany(...)` <br/> `@JoinTable(name="TASK_LIST_TABLE", joinColumns=@JoinColumn(name="TODO_ID"))` (if join table used) <br/> `@OrderColumn` (if `<list-index>` present) | `@org.hibernate.annotations.LazyCollection(LazyCollectionOption.EXTRA)` | `hbm2java` maps `<list>` to `java.util.List`. `lazy="extra"` maps to `@LazyCollection(LazyCollectionOption.EXTRA)`. Presence of `<list-index>` (covered later) adds `@OrderColumn`. |
| `<bag name="events" lazy="false" fetch="join" access="field"> <key column="EVENT_OWNER_ID"/> ... </bag>` | `private java.util.Collection<Event> events;` <br/> `@OneToMany(fetch=FetchType.EAGER)` or `@ManyToMany(fetch=FetchType.EAGER)` <br/> `@Access(AccessType.FIELD)` | `@org.hibernate.annotations.Fetch(FetchMode.JOIN)` | `hbm2java` typically maps `<bag>` to `java.util.Collection` or `java.util.List` if no `order-by` is specified. Attributes are mapped similarly. Bags are unordered and may allow duplicates. |
| `<map name="attributes" table="ATTRIBUTES_MAP" schema="CONFIG" catalog="APP_DB" order-by="key_col desc"> <key column="ENTITY_ID"/> ... </map>` | `private java.util.Map<String, String> attributes;` <br/> `@ElementCollection` or `@OneToMany`/`@ManyToMany` <br/> `@CollectionTable(name="ATTRIBUTES_MAP", schema="CONFIG", catalog="APP_DB", joinColumns=@JoinColumn(name="ENTITY_ID"))` (for ElementCollection) <br/> `@MapKeyColumn(...)` or `@MapKeyJoinColumn(...)` or `@MapKeyEnumerated(...)` etc. (covered later) <br/> `@OrderBy("key_col desc")` |  | `hbm2java` maps `<map>` to `java.util.Map`. `table`, `schema`, `catalog` apply to `@CollectionTable` or `@JoinTable`. Key/Value mapping details (e.g. `<map-key>`, `<element>`) determine the full annotations. |

---
**Collection Element Mappings:**

This table details the mapping of elements *within* collection tags like `<set>`, `<list>`, `<bag>`, and `<map>`.

| HBM XML Snippet (Nested Element)                                                                                                | JPA Annotation(s) on Collection Field / Related Annotations                                                                                                                                                                                                                                                              | Notes                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| :------------------------------------------------------------------------------------------------------------------------------ | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`<element>` (Basic Type)** <br/> `<set name="aliases"> <key column="ENTITY_ID"/> <element column="alias_name" type="string" length="50"/> </set>`                               | `java.util.Set<String> aliases;` <br/> `@ElementCollection` <br/> `@CollectionTable(name="ENTITY_ALIASES", joinColumns=@JoinColumn(name="ENTITY_ID"))` (Table name often defaults or from parent collection tag) <br/> `@Column(name="alias_name", length=50)` (Applied to the collection elements)                               | `<element>` with `type` attribute maps to a collection of basic types using `@ElementCollection`. The `@Column` annotation configures the column for these basic types in the collection table. `length`, `not-null`, etc. on `<element>` map to `@Column` attributes. If `<element>` has nested `<column name="..."/>`, that takes precedence.                                                                                                                                                                                                                                                                                          |
| **`<element>` (Embeddable Type)** <br/> `<set name="historicalAddresses"> <key column="PERSON_ID"/> <element class="com.example.AddressComponent"> <column-prefix>HIST_</column-prefix> <property name="street"/> <property name="city"/> </element> </set>` | `java.util.Set<AddressComponent> historicalAddresses;` <br/> `@ElementCollection` <br/> `@CollectionTable(name="HISTORICAL_ADDRESSES", joinColumns=@JoinColumn(name="PERSON_ID"))` <br/> `@AttributeOverrides({ @AttributeOverride(name="street", column=@Column(name="HIST_STREET")), @AttributeOverride(name="city", column=@Column(name="HIST_CITY")) })` (on `historicalAddresses` field) <br/> `// com.example.AddressComponent is @Embeddable` | If `<element class="...">` is used (or implied if collection type is an embeddable), it maps to `@ElementCollection` of an `@Embeddable` type. Properties of the embeddable are mapped to columns in the collection table. Column names can be defaulted, explicitly set in the `@Embeddable` class, or overridden by `<column-prefix>` or individual property column definitions within `<element>`, translated to `@AttributeOverride` on the `@ElementCollection` field. |
| **`<one-to-many>` (Nested)** <br/> `<set name="phones"> <key column="OWNER_ID"/> <one-to-many class="com.example.Phone"/> </set>`                                                | `java.util.Set<Phone> phones;` <br/> `@OneToMany(mappedBy="ownerFieldInPhone")` (assuming bidirectional) or `@OneToMany @JoinColumn(name="OWNER_ID")` (if unidirectional and `OWNER_ID` is in `Phone` table)                                                                                                                            | `<one-to-many>` nested in a collection tag signifies a one-to-many relationship. `class` is the target entity. `hbm2java` determines `mappedBy` if the relationship is bidirectional (by finding the corresponding `@ManyToOne` in `Phone`). If unidirectional, a `@JoinColumn` (using the `<key column="...">` from HBM) is placed on the `@OneToMany` side, implying the FK is in the target entity's table. |
| **`<many-to-many>` (Nested)** <br/> `<set name="courses" table="STUDENT_COURSES"> <key column="STUDENT_ID"/> <many-to-many class="com.example.Course" column="COURSE_ID" foreign-key="FK_COURSE_IN_JT"/> </set>` | `java.util.Set<Course> courses;` <br/> `@ManyToMany` <br/> `@JoinTable(name="STUDENT_COURSES", joinColumns=@JoinColumn(name="STUDENT_ID"), inverseJoinColumns=@JoinColumn(name="COURSE_ID", foreignKey=@ForeignKey(name="FK_COURSE_IN_JT")) )`                                                                                                  | `<many-to-many>` maps to `@ManyToMany`. `table` attribute of parent collection tag becomes `@JoinTable(name=...)`. The `<key column="..."/>` (sibling to `<many-to-many>`) defines the `joinColumns` (FK for owning entity). The `column` attribute of `<many-to-many>` defines the `inverseJoinColumns` (FK for target entity). `foreign-key` on `<many-to-many>` applies to the `inverseJoinColumns`'s FK constraint. |
| **`<list-index>` (for `<list>`)** <br/> `<list name="chapters"> <key column="BOOK_ID"/> <list-index column="chapter_num"/> <one-to-many class="Chapter"/> </list>`       | `java.util.List<Chapter> chapters;` <br/> `@OneToMany(...)` (or `@ManyToMany(...)`) <br/> `@OrderColumn(name="chapter_num")`                                                                                                                                                                                                | <!-- @org.hibernate.annotations.ListIndexBase(1) (if `base` attribute is present) -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | `<list-index>` inside a `<list>` mapping adds `@OrderColumn(name="...")` to maintain the list order in the database. The `column` attribute specifies the name of this index column. The `base` attribute (Hibernate-specific) can be used to set the starting value of the index, mapped to `@ListIndexBase`. `hbm2java` usually places this on the join table if one exists, or the target table for one-to-many. |
| **`<map-key>` (Basic Type for `<map>`)** <br/> `<map name="systemSettings" table="SETTINGS"> <key column="USER_ID"/> <map-key column="SETTING_NAME" type="string"/> <element column="SETTING_VALUE" type="string"/> </map>` | `java.util.Map<String, String> systemSettings;` <br/> `@ElementCollection` <br/> `@CollectionTable(name="SETTINGS", joinColumns=@JoinColumn(name="USER_ID"))` <br/> `@MapKeyColumn(name="SETTING_NAME")` <br/> `@Column(name="SETTING_VALUE")` (for the map values)                                                               | `<map-key>` defines the mapping for the key of a `java.util.Map` when the key is a basic type. `column` specifies the map key column name. `type` attribute maps to corresponding properties in `@MapKeyColumn` or specific annotations like `@MapKeyEnumerated` or `@MapKeyTemporal` if the type dictates. The value part of the map is defined by a subsequent `<element>`, `<one-to-many>`, etc. |
| **`<composite-map-key>` (Embeddable for `<map>`)** <br/> `<map name="customReports" table="USER_REPORTS"> <key column="USER_ID"/> <composite-map-key class="com.example.ReportKey"> <key-property name="reportName"/> <key-property name="reportVersion"/> </composite-map-key> <one-to-many class="com.example.ReportData"/> </map>` | `java.util.Map<ReportKey, ReportData> customReports;` <br/> `@OneToMany` (or `@ManyToMany`, `@ElementCollection` for values) <br/> `@MapKeyClass(ReportKey.class)` <br/> `// Column mapping for ReportKey fields done via @MapKeyColumn on those fields, or @AttributeOverrides on the collection if columns were in HBM.` | `com.example.ReportKey` must be an `@Embeddable` class. `<composite-map-key>` maps to `@MapKeyClass`. The properties of the map key embeddable (`<key-property>`) are mapped to columns in the join/collection table. `hbm2java` would typically expect these columns to be defined within the HBM for the map key or rely on defaults/overrides. The example shows the setup; actual column names for map key parts depend on how `ReportKey` is defined or if overrides are specified. |

---

## Inheritance Mappings

Covers `<subclass>`, `<joined-subclass>`, `<union-subclass>`, and `<discriminator>`.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator column="ANIMAL_TYPE" type="string" length="20"/> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance (default when `<discriminator>` is present without `<joined-subclass>` or `<union-subclass>`). `discriminator column` maps to `@DiscriminatorColumn name`. `type` maps to `discriminatorType` (STRING, CHAR, INTEGER). `length` is also set. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator formula="CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END" type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | `@org.hibernate.annotations.DiscriminatorFormula("CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END")` | If `formula` is used on `<discriminator>`, it maps to Hibernate's `@DiscriminatorFormula`. `type` on discriminator still informs Hibernate about the expected type of the formula's result. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. `hbm2java` maps this by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though `hbm2java` might map them directly if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity, or in a central place like `package-info.java`) |  | HQL query defined in CDATA section is mapped to the `query` attribute of `@NamedQuery`. `name` attribute is used for `name`. `hbm2java` typically adds these to the relevant entity class. |
| `<sql-query name="findUserWithAddress"> <return alias="user" class="com.example.User"/> <return-join alias="addr" property="user.address"/> <![CDATA[ SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ? ]]> </sql-query>` | `@NamedNativeQuery(name="findUserWithAddress", query="SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ?", resultSetMapping="userWithAddressMapping")` <br/> `@SqlResultSetMapping(name="userWithAddressMapping", entities={@EntityResult(entityClass=com.example.User.class, alias="user", fields={@FieldResult(name="address", column="addr")})})` (Note: `FieldResult` for `return-join` is simplified here; `hbm2java` might map `return-join` to a separate `@EntityResult` if `addr` is an entity, or handle it as part of the main `EntityResult`'s fields if the join is to populate a property of `user`.) |  | SQL query maps to `@NamedNativeQuery`. `<return alias="..." class="..."/>` maps to `@EntityResult(entityClass=...)`. `<return-join property="user.address"/>` (populating a property of the main return) maps to `@FieldResult` within the main `@EntityResult`. A `resultSetMapping` name is generated. If the join returns another full entity, it would be a separate `@EntityResult`. |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <return-scalar column="user_age" type="integer"/> <![CDATA[ SELECT name AS user_name, age AS user_age FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name, age AS user_age FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name", type=String.class), @ColumnResult(name="user_age", type=Integer.class)})` |  | `<return-scalar column="..." type="..."/>` maps to `@ColumnResult(name="...", type=...)` within a `@SqlResultSetMapping`. `hbm2java` derives the Java type from HBM type. |
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber" column="EMP_NO"/> <many-to-one name="department" column="DEPT_ID"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId @Column(name="EMP_NO")` <br/> On `department` field: `@NaturalId @ManyToOne @JoinColumn(name="DEPT_ID")` | `@org.hibernate.annotations.NaturalIdCache` (on class `Employee`, if `<cache>` is also used for natural-id) | Properties within `<natural-id>` are annotated with `@NaturalId`. `mutable="true"` on `<natural-id>` maps to `@NaturalId(mutable=true)` on each field. If a `<cache>` element is associated with the natural ID in HBM (not shown), `@NaturalIdCache` might be added to the entity. `hbm2java` handles this. |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write" region="itemCache"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied, or explicitly if needed for provider) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region="itemCache")` | `<cache usage="..." region="..."/>` nested within a collection tag (like `<set>`, `<list>`, etc.) maps to Hibernate's `@Cache` annotation on the collection field. `usage` maps to `CacheConcurrencyStrategy`. |
| `<class name="MyEntity" optimistic-lock="version"> ... </class>` | (Implicit default if `@Version` is present) |  | `optimistic-lock="version"` (default) implies use of a `<version>` property. `optimistic-lock="all"` would check all fields (less common). `optimistic-lock="dirty"` checks only modified fields. JPA default with `@Version` is similar to "version". `hbm2java` reflects this in generated code, but no specific annotation for "version" itself beyond `@Version` on a property. |
| `<class name="MyEntity" persister="com.example.MyPersister"> ... </class>` | (No direct equivalent) | `@org.hibernate.annotations.Persister(impl=com.example.MyPersister.class)` | `persister` attribute maps to Hibernate's `@Persister` annotation. |
| `<filter-def name="myFilter"> <filter-param name="myParam" type="string"/> </filter-def>` <br/> `<class ...> <filter name="myFilter" condition=":myParam = some_column"/> </class>` | (No direct equivalent for filter definitions. Filters are applied programmatically in JPA.) | `@org.hibernate.annotations.FilterDef(name="myFilter", parameters={@org.hibernate.annotations.ParamDef(name="myParam", type="string")})` (on a class, often package-level) <br/> `@org.hibernate.annotations.Filter(name="myFilter", condition=":myParam = some_column")` (on entity or collection) | `hbm2java` maps `<filter-def>` to `@FilterDef` (often at package level or on a common entity) and `<filter>` to `@Filter` on the specific entity/collection. |

---

## Query Mappings

Covers `<query>` and `<sql-query>`.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator column="ANIMAL_TYPE" type="string" length="20"/> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance (default when `<discriminator>` is present without `<joined-subclass>` or `<union-subclass>`). `discriminator column` maps to `@DiscriminatorColumn name`. `type` maps to `discriminatorType` (STRING, CHAR, INTEGER). `length` is also set. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator formula="CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END" type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | `@org.hibernate.annotations.DiscriminatorFormula("CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END")` | If `formula` is used on `<discriminator>`, it maps to Hibernate's `@DiscriminatorFormula`. `type` on discriminator still informs Hibernate about the expected type of the formula's result. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. `hbm2java` maps this by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though `hbm2java` might map them directly if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity, or in a central place like `package-info.java`) |  | HQL query defined in CDATA section is mapped to the `query` attribute of `@NamedQuery`. `name` attribute is used for `name`. `hbm2java` typically adds these to the relevant entity class. |
| `<sql-query name="findUserWithAddress"> <return alias="user" class="com.example.User"/> <return-join alias="addr" property="user.address"/> <![CDATA[ SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ? ]]> </sql-query>` | `@NamedNativeQuery(name="findUserWithAddress", query="SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ?", resultSetMapping="userWithAddressMapping")` <br/> `@SqlResultSetMapping(name="userWithAddressMapping", entities={@EntityResult(entityClass=com.example.User.class, alias="user", fields={@FieldResult(name="address", column="addr")})})` (Note: `FieldResult` for `return-join` is simplified here; `hbm2java` might map `return-join` to a separate `@EntityResult` if `addr` is an entity, or handle it as part of the main `EntityResult`'s fields if the join is to populate a property of `user`.) |  | SQL query maps to `@NamedNativeQuery`. `<return alias="..." class="..."/>` maps to `@EntityResult(entityClass=...)`. `<return-join property="user.address"/>` (populating a property of the main return) maps to `@FieldResult` within the main `@EntityResult`. A `resultSetMapping` name is generated. If the join returns another full entity, it would be a separate `@EntityResult`. |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <return-scalar column="user_age" type="integer"/> <![CDATA[ SELECT name AS user_name, age AS user_age FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name, age AS user_age FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name", type=String.class), @ColumnResult(name="user_age", type=Integer.class)})` |  | `<return-scalar column="..." type="..."/>` maps to `@ColumnResult(name="...", type=...)` within a `@SqlResultSetMapping`. `hbm2java` derives the Java type from HBM type. |
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber" column="EMP_NO"/> <many-to-one name="department" column="DEPT_ID"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId @Column(name="EMP_NO")` <br/> On `department` field: `@NaturalId @ManyToOne @JoinColumn(name="DEPT_ID")` | `@org.hibernate.annotations.NaturalIdCache` (on class `Employee`, if `<cache>` is also used for natural-id) | Properties within `<natural-id>` are annotated with `@NaturalId`. `mutable="true"` on `<natural-id>` maps to `@NaturalId(mutable=true)` on each field. If a `<cache>` element is associated with the natural ID in HBM (not shown), `@NaturalIdCache` might be added to the entity. `hbm2java` handles this. |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write" region="itemCache"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied, or explicitly if needed for provider) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region="itemCache")` | `<cache usage="..." region="..."/>` nested within a collection tag (like `<set>`, `<list>`, etc.) maps to Hibernate's `@Cache` annotation on the collection field. `usage` maps to `CacheConcurrencyStrategy`. |

---

## Other Mappings

Covers other tags like `<natural-id>`, `<cache>`, etc.

| HBM XML Snippet                 | JPA Annotation(s)               | Hibernate Annotation(s) (if needed) | Notes                                    |
| :------------------------------ | :------------------------------ | :---------------------------------- | :--------------------------------------- |
| `<class name="Animal" table="ANIMALS"> <id name="id"/> <discriminator column="ANIMAL_TYPE" type="string" length="20"/> <property name="name"/> <subclass name="Dog" discriminator-value="DOG"> <property name="breed"/> </subclass> <subclass name="Cat" discriminator-value="CAT"> <property name="lives"/> </subclass> </class>` | On `Animal` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE) @DiscriminatorColumn(name="ANIMAL_TYPE", discriminatorType=DiscriminatorType.STRING, length=20)` <br/> On `Dog` (subclass): `@Entity @DiscriminatorValue("DOG")` <br/> On `Cat` (subclass): `@Entity @DiscriminatorValue("CAT")` |  | For `SINGLE_TABLE` inheritance (default when `<discriminator>` is present without `<joined-subclass>` or `<union-subclass>`). `discriminator column` maps to `@DiscriminatorColumn name`. `type` maps to `discriminatorType` (STRING, CHAR, INTEGER). `length` is also set. Each `<subclass name="..." discriminator-value="..."/>` becomes an `@Entity` extending the superclass and gets a `@DiscriminatorValue`. |
| `<class name="Payment"> <id name="id"/> <discriminator formula="CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END" type="string"/> ... </class>` | On `Payment` (superclass): `@Inheritance(strategy=InheritanceType.SINGLE_TABLE)` | `@org.hibernate.annotations.DiscriminatorFormula("CASE WHEN card_type IS NOT NULL THEN 'CC' ELSE 'CASH' END")` | If `formula` is used on `<discriminator>`, it maps to Hibernate's `@DiscriminatorFormula`. `type` on discriminator still informs Hibernate about the expected type of the formula's result. |
| `<class name="Vehicle" table="VEHICLES"> <id name="id"/> ... <joined-subclass name="Car" table="CARS"> <key column="VEHICLE_ID"/> <property name="numDoors"/> </joined-subclass> </class>` | On `Vehicle` (superclass): `@Inheritance(strategy=InheritanceType.JOINED)` <br/> On `Car` (subclass): `@Entity @Table(name="CARS") @PrimaryKeyJoinColumn(name="VEHICLE_ID")` |  | For `JOINED` strategy. `<joined-subclass name="..." table="..."/>` becomes an `@Entity` extending superclass, with its own `@Table`. The `<key column="..."/>` within `<joined-subclass>` maps to `@PrimaryKeyJoinColumn(name=...)` on the subclass. |
| `<class name="Gadget" table="GADGETS_ROOT"> <id name="id"/> ... <union-subclass name="Phone" table="PHONES"> <property name="phoneNumber"/> </union-subclass> <union-subclass name="Camera" table="CAMERAS"> <property name="pixels"/> </union-subclass> </class>` | On `Gadget` (superclass): `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` <br/> On `Phone` (subclass): `@Entity @Table(name="PHONES") @AttributeOverride(name="id", column=@Column(name="id"))` (if id column name is same as root) <br/> On `Camera` (subclass): `@Entity @Table(name="CAMERAS") @AttributeOverride(name="id", column=@Column(name="id"))` |  | For `TABLE_PER_CLASS` strategy. Each `<union-subclass name="..." table="..."/>` becomes an `@Entity` with its own `@Table`. `hbm2java` maps this by setting `@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)` on the root entity. Subclasses might need `@AttributeOverride` for inherited properties if column names need to be specified per subclass table, though `hbm2java` might map them directly if column names are consistent or defined in HBM. IDs are usually duplicated in each table. |
| `<query name="findAllUsers"> <![CDATA[ FROM User u ORDER BY u.name ]]> </query>` | `@NamedQuery(name="findAllUsers", query="FROM User u ORDER BY u.name")` (on an entity, or in a central place like `package-info.java`) |  | HQL query defined in CDATA section is mapped to the `query` attribute of `@NamedQuery`. `name` attribute is used for `name`. `hbm2java` typically adds these to the relevant entity class. |
| `<sql-query name="findUserWithAddress"> <return alias="user" class="com.example.User"/> <return-join alias="addr" property="user.address"/> <![CDATA[ SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ? ]]> </sql-query>` | `@NamedNativeQuery(name="findUserWithAddress", query="SELECT u.*, a.* FROM USERS u JOIN ADDRESSES a ON u.ADDR_ID = a.ID WHERE u.ID = ?", resultSetMapping="userWithAddressMapping")` <br/> `@SqlResultSetMapping(name="userWithAddressMapping", entities={@EntityResult(entityClass=com.example.User.class, alias="user", fields={@FieldResult(name="address", column="addr")})})` (Note: `FieldResult` for `return-join` is simplified here; `hbm2java` might map `return-join` to a separate `@EntityResult` if `addr` is an entity, or handle it as part of the main `EntityResult`'s fields if the join is to populate a property of `user`.) |  | SQL query maps to `@NamedNativeQuery`. `<return alias="..." class="..."/>` maps to `@EntityResult(entityClass=...)`. `<return-join property="user.address"/>` (populating a property of the main return) maps to `@FieldResult` within the main `@EntityResult`. A `resultSetMapping` name is generated. If the join returns another full entity, it would be a separate `@EntityResult`. |
| `<sql-query name="listUserValues"> <return-scalar column="user_name" type="string"/> <return-scalar column="user_age" type="integer"/> <![CDATA[ SELECT name AS user_name, age AS user_age FROM USERS ]]> </sql-query>` | `@NamedNativeQuery(name="listUserValues", query="SELECT name AS user_name, age AS user_age FROM USERS", resultSetMapping="userValuesMapping")` <br/> `@SqlResultSetMapping(name="userValuesMapping", columns={@ColumnResult(name="user_name", type=String.class), @ColumnResult(name="user_age", type=Integer.class)})` |  | `<return-scalar column="..." type="..."/>` maps to `@ColumnResult(name="...", type=...)` within a `@SqlResultSetMapping`. `hbm2java` derives the Java type from HBM type. |
| `<class name="Employee"> ... <natural-id mutable="true"> <property name="employeeNumber" column="EMP_NO"/> <many-to-one name="department" column="DEPT_ID"/> </natural-id> ... </class>` | On `employeeNumber` field: `@NaturalId @Column(name="EMP_NO")` <br/> On `department` field: `@NaturalId @ManyToOne @JoinColumn(name="DEPT_ID")` | `@org.hibernate.annotations.NaturalIdCache` (on class `Employee`, if `<cache>` is also used for natural-id) | Properties within `<natural-id>` are annotated with `@NaturalId`. `mutable="true"` on `<natural-id>` maps to `@NaturalId(mutable=true)` on each field. If a `<cache>` element is associated with the natural ID in HBM (not shown), `@NaturalIdCache` might be added to the entity. `hbm2java` handles this. |
| `<set name="items"> <key column="OWNER_ID"/> <cache usage="read-write" region="itemCache"/> <one-to-many class="Item"/> </set>` | On `items` collection field: `@Cacheable` (implied, or explicitly if needed for provider) | `@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE, region="itemCache")` | `<cache usage="..." region="..."/>` nested within a collection tag (like `<set>`, `<list>`, etc.) maps to Hibernate's `@Cache` annotation on the collection field. `usage` maps to `CacheConcurrencyStrategy`. |
