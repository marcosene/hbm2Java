import re

# Comprehensive list of phrases indicating non-implementation or non-processing
NON_IMPLEMENTED_PHRASES = [
    "not implemented", 
    "not supported", 
    "not typically processed", 
    "not currently implemented", 
    "not generated by the tool", 
    "ignored by the tool", 
    "not used for annotation generation", 
    "do not affect generated annotations", 
    "values are typically ignored",
    "is not listed as implemented",
    "not processed for direct annotation generation",
    "not typically processed for standard JPA annotation generation",
    "not implemented for annotation generation",
    "is not currently implemented", # variation
    "are not typically processed for direct annotation generation relevant to core entity model construction", # Specific long one
    "are not typically processed for direct annotation generation", # General version
    "attributes for .*? like .*? are not typically processed for standard JPA annotation generation" # For query/sql-query
]

# Specific HBM patterns that indicate a feature for potential row removal if it's the *primary* focus
# and associated notes confirm non-implementation.
HBM_FEATURES_TO_SCRUTINIZE = {
    "<element": "HBM <element> for collections", 
    "formula=": "formula attribute" 
}

# HTML comments to remove
COMMENTS_TO_REMOVE_PATTERNS = [
    re.compile(r"<!-- schema, catalog, package attributes for hibernate-mapping are not typically processed for direct annotation generation\. -->", re.IGNORECASE),
    re.compile(r"<!-- Other attributes like 'schema', 'catalog', 'proxy', 'lazy', 'batch-size', 'select-before-update', 'optimistic-lock' for <class> are not typically processed.*? -->", re.IGNORECASE),
    re.compile(r"<!-- The 'column' attribute directly on <version> is not used for column name if a nested <column> is present\. -->", re.IGNORECASE),
    re.compile(r"<!-- Attributes like 'access', 'insert', 'update', 'optimistic-lock', 'node', 'embed-xml' for <component> are not typically processed.*? -->", re.IGNORECASE),
    re.compile(r"<!-- For <properties>, attributes like 'node', 'insert', 'update', 'optimistic-lock' are not typically processed.*? -->", re.IGNORECASE),
    re.compile(r"<!-- Removed update=\"false\" for relationships as it's not commonly used.*?For now, focusing on more direct mappings\. -->", re.IGNORECASE),
    re.compile(r"<!-- Union-subclass is covered in Class Mappings\. -->", re.IGNORECASE),
    re.compile(r"<!-- Other <cache> attributes like 'include' are not typically processed\. -->", re.IGNORECASE),
    re.compile(r"<!-- A nested <cache> element specifically for <natural-id> is not typically parsed.*? -->", re.IGNORECASE),
    re.compile(r"<!-- Only <return-scalar> is typically processed for standard JPA annotation generation from <sql-query> children\..*? -->", re.IGNORECASE),
    re.compile(r"<!-- Attributes for <query> and <sql-query> like .*? are not typically processed.*? -->", re.IGNORECASE),
    re.compile(r"<!-- Persister, filter-def, filter, optimistic-lock attribute on class are not implemented\. -->", re.IGNORECASE),
    re.compile(r"<!-- The following table was the \"Collection Element Mappings\" section\. It is removed because the <element> tag for basic/embeddable collections is not implemented\. -->", re.IGNORECASE),
    re.compile(r"<!-- @org.hibernate.annotations.ListIndexBase\(1\) \(if `base` attribute is present\) -->", re.IGNORECASE)
]

def clean_note_cell(note_text):
    if not note_text:
        return ""
    
    parts = re.split(r'(\s*<br/>\s*)', note_text)
    cleaned_parts = []
    
    for part_idx, part in enumerate(parts):
        if not part or re.fullmatch(r'\s*<br/>\s*', part):
            if part and cleaned_parts and not re.fullmatch(r'\s*<br/>\s*', cleaned_parts[-1]):
                 cleaned_parts.append(part)
            continue

        modified_sentence = part
        sentence_fully_about_non_implementation = False

        for phrase in NON_IMPLEMENTED_PHRASES:
            # Test if removing the phrase makes the sentence empty or just punctuation
            # This helps determine if the *entire sentence* is about non-implementation
            # We need to be careful with punctuation and whitespace.
            # A more robust check: see if the phrase is a very large portion of the sentence.
            # Or, if after removing the phrase, what's left is very short / non-substantive.
            
            # Create a pattern that matches the phrase, possibly surrounded by sentence-ending punctuation.
            # Example: "Feature X is not implemented." -> remove "is not implemented"
            # If "Feature X." remains, it's not useful.
            
            # Simpler approach: if the phrase is in the sentence, remove the sentence.
            # This is aggressive but matches the "remove *any* sentence, phrase, or part of a sentence" instruction.
            if phrase.lower() in modified_sentence.lower():
                # Check if this phrase is the bulk of the sentence
                # A simple heuristic: if the phrase is more than 50% of the sentence length
                if len(phrase) > 0.5 * len(modified_sentence.strip()):
                    sentence_fully_about_non_implementation = True
                    break 
                else: # If it's a smaller part, just remove the phrase
                    modified_sentence = re.sub(r'(?i)\b' + re.escape(phrase) + r'\b\.?', "", modified_sentence).strip()


        if not sentence_fully_about_non_implementation and modified_sentence.strip() and modified_sentence.strip() != ".":
            cleaned_parts.append(modified_sentence.strip())
        elif sentence_fully_about_non_implementation:
            pass # Entire sentence was about non-implementation, so it's removed
            
    # Reconstruct and cleanup
    final_note = "".join(cleaned_parts).strip()
    current_br_pattern = r"(\s*<br/>\s*)"
    # Remove <br/> if it's at the beginning or end of the note
    final_note = re.sub(f"^{current_br_pattern}+|{current_br_pattern}+$", "", final_note)
    # Replace multiple <br/> with a single one
    final_note = re.sub(f"{current_br_pattern}{{2,}}", " <br/> ", final_note)
    final_note = final_note.replace("..", ".").replace(". .", ".") # Fix periods
    final_note = final_note.strip(" .,;") # Final strip of common trailing punctuation
    
    return final_note

def process_tables_for_unimplemented(lines):
    new_lines = []
    in_table = False
    header_cells = []
    column_indices = {}
    
    i = 0
    while i < len(lines):
        line = lines[i]
        stripped_line = line.strip()

        if stripped_line.startswith("|") and ":---" in lines[i+1 if i+1 < len(lines) else i]:
            # This is likely a header row
            if not stripped_line.endswith("|"): # Handle cases where header might be oddly split by mistake
                 if i+1 < len(lines) and lines[i+1].strip().startswith("|") and lines[i+1].strip().endswith("|"): # Check if next line is separator
                     # Assume this is a valid header
                     pass
                 else: # Not a clear table header
                     new_lines.append(line)
                     i+=1
                     continue
            
            in_table = True
            new_lines.append(line) # Header
            header_cells = [cell.strip() for cell in stripped_line.strip("|").split("|")]
            try:
                column_indices['hbm'] = header_cells.index("HBM XML Snippet")
                column_indices['jpa_hib'] = header_cells.index("JPA/Hibernate Annotation(s)")
                column_indices['notes'] = header_cells.index("Notes")
            except ValueError: 
                column_indices = {}
            
            i += 1
            new_lines.append(lines[i]) # Separator
            i += 1
            continue

        if not in_table:
            new_lines.append(line)
            i += 1
            continue

        if not stripped_line.startswith("|"): 
            in_table = False
            header_cells = []
            column_indices = {}
            new_lines.append(line)
            i += 1
            continue

        # Inside a table data row
        row_cells_raw = [cell.strip() for cell in stripped_line.strip("|").split("|")]
        
        row_cells = list(row_cells_raw) 
        while len(row_cells) < len(header_cells): # Ensure enough cells for safety
            row_cells.append("")

        hbm_snippet = row_cells[column_indices.get('hbm', 0)] if 'hbm' in column_indices and len(row_cells) > column_indices['hbm'] else ""
        notes_content_original = row_cells[column_indices.get('notes', -1)] if 'notes' in column_indices and len(row_cells) > column_indices['notes'] else ""
        
        cleaned_note = clean_note_cell(notes_content_original)
        if 'notes' in column_indices and len(row_cells) > column_indices['notes']:
             row_cells[column_indices['notes']] = cleaned_note
        
        delete_row = False
        
        # Stricter row deletion: if the original note was *entirely* about non-implementation,
        # and the cleaned note is now empty, the row's purpose was to document this non-implementation.
        original_note_was_entirely_about_non_implementation = False
        if notes_content_original.strip(): # Only if there was an original note
            temp_cleaned_original_note = notes_content_original
            for phrase in NON_IMPLEMENTED_PHRASES:
                # A bit more robust check: if removing the phrase significantly reduces the note or makes it empty
                # This means the phrase was a core part of the note.
                if phrase.lower() in temp_cleaned_original_note.lower():
                    # If removing this phrase makes the note empty or very short (e.g. just punctuation)
                    if len(re.sub(r'(?i)\b' + re.escape(phrase) + r'\b\.?', "", temp_cleaned_original_note).strip(" .,;<br/>")) < 5: # Heuristic for "very short"
                        original_note_was_entirely_about_non_implementation = True
                        break
            if original_note_was_entirely_about_non_implementation and not cleaned_note.strip():
                delete_row = True

        # Also, check for specific HBM features that are primary subjects of non-implementation
        if not delete_row: # Only if not already flagged by general note-based deletion
            for feature_key, feature_name in HBM_FEATURES_TO_SCRUTINIZE.items():
                if feature_key in hbm_snippet:
                    # Check if the original note confirmed non-implementation for this specific feature.
                    # This implies the row's main purpose might be to show this non-implemented feature.
                    note_confirmed_feature_unimplemented = False
                    for phrase in NON_IMPLEMENTED_PHRASES:
                        if phrase in notes_content_original.lower() and (feature_key in notes_content_original.lower() or feature_name in notes_content_original.lower()):
                            note_confirmed_feature_unimplemented = True
                            break
                    if note_confirmed_feature_unimplemented and not cleaned_note.strip():
                        # Heuristic: if HBM snippet is relatively simple and focuses on this feature
                         if len(hbm_snippet) < len(feature_key) + 40 : # Adjusted length
                            delete_row = True
                            break
        
        if not delete_row:
            final_row_cells = [" " if cell.strip() == "" else cell.strip() for cell in row_cells]
            new_lines.append("| " + " | ".join(final_row_cells) + " |")
        
        i += 1
        continue
        
    return new_lines


def remove_unimplemented_features_master(markdown_content):
    markdown_content = re.sub(
        r"Covers primary key mappings\. `<composite-id>` is not listed as implemented, so examples are focused on `<id>`\.",
        "Covers primary key mappings. Examples are focused on `<id>`.",
        markdown_content,
        flags=re.IGNORECASE
    )

    standalone_note_pattern = re.compile(
        r"\*\*Note on HBM `<element>` for Collections:\*\* The HBM `<element>` tag, which would typically be used for mapping collections of basic or embeddable types .*?is \*\*not implemented\*\* in this version of the `hbm2java` tool\..*?Therefore, direct mapping of such collections using `<element>` is not supported\.",
        re.DOTALL | re.IGNORECASE
    )
    markdown_content = standalone_note_pattern.sub("", markdown_content)
    
    lines = markdown_content.splitlines()

    temp_lines_after_comments = []
    for line in lines:
        modified_line = line
        for pattern in COMMENTS_TO_REMOVE_PATTERNS:
            modified_line = pattern.sub("", modified_line)
        # Only add line if it's not empty OR if original line was empty (to preserve deliberate blank lines)
        if modified_line.strip() or (not line.strip() and not modified_line.strip()):
             temp_lines_after_comments.append(modified_line)
    lines = temp_lines_after_comments
    
    lines = process_tables_for_unimplemented(lines)

    final_lines = []
    last_line_blank = False
    for line_idx, line in enumerate(lines):
        stripped_line = line.strip()
        if stripped_line:
            # Specific check for table separator lines that might be followed by empty table content if all rows were deleted
            if re.match(r"\|(:---[:|-]*)+\|", stripped_line): # It's a separator line
                # Peek ahead: if next line is NOT a data row (doesn't start with |) or end of lines,
                # it means this table has no more data rows.
                if line_idx + 1 >= len(lines) or not lines[line_idx+1].strip().startswith("|"):
                    # This separator is for an empty table. Remove it and the header before it.
                    # Search backwards for the corresponding header
                    if final_lines: # ensure final_lines is not empty
                        # find the last non-empty line that is a header
                        for k in range(len(final_lines) -1, -1, -1):
                            if final_lines[k].strip().startswith("|") and not re.match(r"\|(:---[:|-]*)+\|", final_lines[k].strip()):
                                final_lines.pop(k) # remove header
                                break 
                    continue # Don't add this separator

            final_lines.append(line)
            last_line_blank = False
        elif not last_line_blank: 
            final_lines.append("")
            last_line_blank = True
            
    while final_lines and final_lines[-1].strip() == "":
        final_lines.pop()

    output = "\n".join(final_lines)
    if output and not output.endswith("\n"): 
        output += "\n"
    return output

if __name__ == "__main__":
    file_path = "HBM_to_JPA_Mapping_Guide.md"
    with open(file_path, "r", encoding="utf-8") as f:
        content = f.read()
    
    modified_content = remove_unimplemented_features_master(content)
    
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(modified_content)
    
    print(f"Successfully performed comprehensive cleanup of unimplemented features in {file_path}")
