import re

# Comprehensive list of phrases indicating non-implementation or non-processing
NON_IMPLEMENTED_PHRASES = [
    "not implemented", 
    "not supported", 
    "not typically processed", 
    "not currently implemented", 
    "not generated by the tool", 
    "ignored by the tool", 
    "not used for annotation generation", 
    "do not affect generated annotations", 
    "values are typically ignored",
    "is not listed as implemented",
    "not processed for direct annotation generation",
    "not typically processed for standard JPA annotation generation",
    "not implemented for annotation generation",
    "is not currently implemented", # variation
    "are not typically processed for direct annotation generation relevant to core entity model construction", 
    "are not typically processed for direct annotation generation", 
    "attributes for .*? like .*? are not typically processed for standard JPA annotation generation"
]

HBM_FEATURES_TO_SCRUTINIZE = {
    "<element": "HBM <element> for collections", 
    "formula=": "formula attribute" 
}

COMMENTS_TO_REMOVE_PATTERNS = [
    re.compile(r"<!-- schema, catalog, package attributes for hibernate-mapping are not typically processed for direct annotation generation\. -->", re.IGNORECASE),
    re.compile(r"<!-- Other attributes like 'schema', 'catalog', 'proxy', 'lazy', 'batch-size', 'select-before-update', 'optimistic-lock' for <class> are not typically processed.*? -->", re.IGNORECASE),
    re.compile(r"<!-- The 'column' attribute directly on <version> is not used for column name if a nested <column> is present\. -->", re.IGNORECASE),
    re.compile(r"<!-- Attributes like 'access', 'insert', 'update', 'optimistic-lock', 'node', 'embed-xml' for <component> are not typically processed.*? -->", re.IGNORECASE),
    re.compile(r"<!-- For <properties>, attributes like 'node', 'insert', 'update', 'optimistic-lock' are not typically processed.*? -->", re.IGNORECASE),
    re.compile(r"<!-- Removed update=\"false\" for relationships as it's not commonly used.*?For now, focusing on more direct mappings\. -->", re.IGNORECASE),
    re.compile(r"<!-- Union-subclass is covered in Class Mappings\. -->", re.IGNORECASE),
    re.compile(r"<!-- Other <cache> attributes like 'include' are not typically processed\. -->", re.IGNORECASE),
    re.compile(r"<!-- A nested <cache> element specifically for <natural-id> is not typically parsed.*? -->", re.IGNORECASE),
    re.compile(r"<!-- Only <return-scalar> is typically processed for standard JPA annotation generation from <sql-query> children\..*? -->", re.IGNORECASE),
    re.compile(r"<!-- Attributes for <query> and <sql-query> like .*? are not typically processed.*? -->", re.IGNORECASE),
    re.compile(r"<!-- Persister, filter-def, filter, optimistic-lock attribute on class are not implemented\. -->", re.IGNORECASE),
    re.compile(r"<!-- The following table was the \"Collection Element Mappings\" section\. It is removed because the <element> tag for basic/embeddable collections is not implemented\. -->", re.IGNORECASE),
    re.compile(r"<!-- @org.hibernate.annotations.ListIndexBase\(1\) \(if `base` attribute is present\) -->", re.IGNORECASE)
]

def clean_note_cell(note_text):
    if not note_text:
        return ""
    
    note_text = re.sub(r'@ElementCollection', '', note_text, flags=re.IGNORECASE)
    note_text = re.sub(r'HBM `<element>` for mapping basic/embeddable value types to `@ElementCollection` is not currently implemented\.', '', note_text, flags=re.IGNORECASE)
    note_text = re.sub(r'HBM `<element>` for mapping basic/embeddable value types.*?is not currently implemented\.', '', note_text, flags=re.IGNORECASE) # More general
    note_text = re.sub(r'HBM `<element>` is not implemented\.', '', note_text, flags=re.IGNORECASE)
    note_text = re.sub(r'\(e\.g\.\s*`<element>`,\s*(`<one-to-many>`)\)', r'(e.g. \1)', note_text, flags=re.IGNORECASE)
    note_text = re.sub(r'\(e\.g\.\s*(`<one-to-many>`),\s*`<element>`\)', r'(e.g. \1)', note_text, flags=re.IGNORECASE)
    # If a sentence becomes "Specific content of set (e.g. ) determines full mapping." change to "Specific content of set (e.g. <one-to-many>) determines full mapping."
    note_text = re.sub(r'\(e\.g\.\s*\)', '(e.g. `<one-to-many>`)', note_text)


    parts = re.split(r'(\s*<br/>\s*)', note_text)
    cleaned_parts = []
    
    for part_idx, part in enumerate(parts):
        if not part or re.fullmatch(r'\s*<br/>\s*', part):
            if part and cleaned_parts and not re.fullmatch(r'\s*<br/>\s*', cleaned_parts[-1]):
                 cleaned_parts.append(part)
            continue

        modified_sentence = part
        sentence_fully_about_non_implementation = False

        for phrase in NON_IMPLEMENTED_PHRASES:
            if phrase.lower() in modified_sentence.lower():
                if len(phrase) > 0.5 * len(modified_sentence.strip()): # Heuristic: phrase is major part
                    sentence_fully_about_non_implementation = True
                    break 
                else: 
                    modified_sentence = re.sub(r'(?i)\b' + re.escape(phrase) + r'\b\.?', "", modified_sentence).strip()

        if not sentence_fully_about_non_implementation and modified_sentence.strip() and modified_sentence.strip() != ".":
            cleaned_parts.append(modified_sentence.strip())
        elif sentence_fully_about_non_implementation:
            pass 
            
    final_note = "".join(cleaned_parts).strip()
    current_br_pattern = r"(\s*<br/>\s*)"
    final_note = re.sub(f"^{current_br_pattern}+|{current_br_pattern}+$", "", final_note)
    final_note = re.sub(f"{current_br_pattern}{{2,}}", " <br/> ", final_note)
    final_note = final_note.replace("..", ".").replace(". .", ".") 
    final_note = re.sub(r'\s*\.\s*<br/>', ' <br/> ', final_note) # ". <br/>" -> " <br/> "
    final_note = re.sub(r'\s*,\s*<br/>', ' <br/> ', final_note) # ", <br/>" -> " <br/> "
    final_note = final_note.strip(" .,;") 
    
    return final_note

def clean_jpa_cell(jpa_text):
    if not jpa_text: return ""
    
    # Remove @ElementCollection and its variants
    jpa_text = re.sub(r'@ElementCollection\s*or\b', '', jpa_text, flags=re.IGNORECASE) # "@ElementCollection or "
    jpa_text = re.sub(r'\bor\s*@ElementCollection\b', '', jpa_text, flags=re.IGNORECASE) # " or @ElementCollection"
    jpa_text = re.sub(r'@ElementCollection', '', jpa_text, flags=re.IGNORECASE) # Standalone @ElementCollection
    
    # Remove @CollectionTable(...) specifically when it's qualified with "(for ElementCollection)"
    jpa_text = re.sub(r'@CollectionTable\([^)]*\)\s*\(for ElementCollection\)', '', jpa_text, flags=re.IGNORECASE)
    # Remove general ", @ElementCollection" from lists like in "General Collection Attributes & Concepts"
    jpa_text = re.sub(r',?\s*@ElementCollection\b', '', jpa_text)


    # Cleanup leftover "or" or dangling commas/markup from removals
    jpa_text = re.sub(r'\s+or\s*<br/>', '<br/>', jpa_text, flags=re.IGNORECASE) # " or <br/>" -> "<br/>"
    jpa_text = re.sub(r'<br/>\s*or\s+', '<br/>', jpa_text, flags=re.IGNORECASE) # "<br/> or " -> "<br/>"
    jpa_text = re.sub(r'\s+or\s+', ' ', jpa_text) # " X or Y " -> " X Y " (if Y remains) or " X "
    jpa_text = jpa_text.replace("or     ", "") # Specific cleanup for map example if 'or' is left
    jpa_text = re.sub(r',\s*,', ',', jpa_text) # ",," -> ","
    jpa_text = re.sub(r'(,\s*)+<br/>', '<br/>', jpa_text) # ", <br/>" -> "<br/>"
    jpa_text = re.sub(r'<br/>\s*,', '<br/>', jpa_text) # "<br/> ," -> "<br/>"
    jpa_text = re.sub(r'\s*,\s*$', '', jpa_text) # Trailing comma after other ops
    jpa_text = jpa_text.strip(" .,;<br/>") # General strip
    
    # Consolidate multiple <br/> and ensure spacing
    jpa_text = re.sub(r"(\s*<br/>\s*){2,}", " <br/> ", jpa_text).strip()
    # Remove dangling periods if they are the only thing left on a line segment
    jpa_text = re.sub(r'<br/>\s*\.\s*<br/>', '<br/> <br/>', jpa_text) # <br/> . <br/> -> <br/> <br/>
    jpa_text = re.sub(r'^\s*\.\s*<br/>', '<br/>', jpa_text) # . <br/> at start
    jpa_text = re.sub(r'<br/>\s*\.\s*$', '<br/>', jpa_text) # <br/> . at end
    if jpa_text == ".": jpa_text = ""


    return jpa_text.strip(" .,;<br/>")


def process_tables_for_unimplemented(lines):
    new_lines = []
    in_table = False
    header_cells = []
    column_indices = {}
    
    i = 0
    while i < len(lines):
        line = lines[i]
        stripped_line = line.strip()

        is_header = stripped_line.startswith("|") and \
                    stripped_line.endswith("|") and \
                    i + 1 < len(lines) and \
                    ":---" in lines[i+1].strip()
        
        if is_header:
            in_table = True
            new_lines.append(line) 
            header_cells = [cell.strip() for cell in stripped_line.strip("|").split("|")]
            try:
                column_indices['hbm'] = header_cells.index("HBM XML Snippet")
                column_indices['jpa_hib'] = header_cells.index("JPA/Hibernate Annotation(s)")
                column_indices['notes'] = header_cells.index("Notes")
            except ValueError: 
                column_indices = {}
            i += 1
            new_lines.append(lines[i]) 
            i += 1
            continue

        if not in_table:
            new_lines.append(line)
            i += 1
            continue

        if not stripped_line.startswith("|"): 
            in_table = False
            header_cells = []
            column_indices = {}
            new_lines.append(line)
            i += 1
            continue

        row_cells_raw = [cell.strip() for cell in stripped_line.strip("|").split("|")]
        row_cells = list(row_cells_raw) 
        while len(row_cells) < len(header_cells):
            row_cells.append("")

        hbm_snippet = row_cells[column_indices.get('hbm', 0)] if 'hbm' in column_indices and len(row_cells) > column_indices['hbm'] else ""
        jpa_content_original = row_cells[column_indices.get('jpa_hib', -1)] if 'jpa_hib' in column_indices and len(row_cells) > column_indices['jpa_hib'] else ""
        notes_content_original = row_cells[column_indices.get('notes', -1)] if 'notes' in column_indices and len(row_cells) > column_indices['notes'] else ""
        
        cleaned_note = clean_note_cell(notes_content_original)
        cleaned_jpa = clean_jpa_cell(jpa_content_original)

        if 'notes' in column_indices and len(row_cells) > column_indices['notes']:
             row_cells[column_indices['notes']] = cleaned_note
        if 'jpa_hib' in column_indices and len(row_cells) > column_indices['jpa_hib']:
             row_cells[column_indices['jpa_hib']] = cleaned_jpa
        
        delete_row = False
        if "<element" in hbm_snippet.lower() and \
           (not cleaned_jpa or cleaned_jpa == " ") and \
           (not cleaned_note or cleaned_note == " "):
            delete_row = True
        
        if not delete_row and notes_content_original.strip():
            original_note_was_entirely_about_non_implementation = False
            temp_cleaned_original_note = notes_content_original
            for phrase in NON_IMPLEMENTED_PHRASES:
                if phrase.lower() in temp_cleaned_original_note.lower():
                    if len(re.sub(r'(?i)\b' + re.escape(phrase) + r'\b\.?', "", temp_cleaned_original_note).strip(" .,;<br/>")) < 10: 
                        original_note_was_entirely_about_non_implementation = True
                        break
            if original_note_was_entirely_about_non_implementation and not cleaned_note.strip():
                delete_row = True
        
        if not delete_row:
            final_row_cells = [" " if cell.strip() == "" else cell.strip() for cell in row_cells]
            # If all cells are empty after cleaning, consider deleting the row
            if all(not cell.strip() for cell in final_row_cells):
                delete_row = True
        
        if not delete_row:
            new_lines.append("| " + " | ".join(final_row_cells) + " |")
        
        i += 1
        continue
        
    return new_lines


def remove_unimplemented_features_master(markdown_content):
    markdown_content = re.sub(
        r"Covers primary key mappings\. `<composite-id>` is not listed as implemented, so examples are focused on `<id>`\.",
        "Covers primary key mappings. Examples are focused on `<id>`.",
        markdown_content,
        flags=re.IGNORECASE
    )

    standalone_note_pattern = re.compile(
        r"\*\*Note on HBM `<element>` for Collections:\*\* The HBM `<element>` tag, which would typically be used for mapping collections of basic or embeddable types .*?is \*\*not implemented\*\* in this version of the `hbm2java` tool\..*?Therefore, direct mapping of such collections using `<element>` is not supported\.",
        re.DOTALL | re.IGNORECASE
    )
    markdown_content = standalone_note_pattern.sub("", markdown_content)
    
    lines = markdown_content.splitlines()

    temp_lines_after_comments = []
    for line in lines:
        modified_line = line
        for pattern in COMMENTS_TO_REMOVE_PATTERNS:
            modified_line = pattern.sub("", modified_line)
        if modified_line.strip() or (not line.strip() and not modified_line.strip()):
             temp_lines_after_comments.append(modified_line)
    lines = temp_lines_after_comments
    
    lines = process_tables_for_unimplemented(lines)

    processed_content = "\n".join(lines)
    # Global cleanup is now mostly handled within clean_jpa_cell and clean_note_cell
    # but a final pass for @ElementCollection can be done
    processed_content = re.sub(r'@ElementCollection', '', processed_content, flags=re.IGNORECASE)

    lines = processed_content.splitlines()

    final_lines = []
    last_line_blank = False
    for line_idx, line in enumerate(lines):
        stripped_line = line.strip()
        if stripped_line:
            if re.match(r"\|(:---[:|-]*)+\|", stripped_line): 
                if line_idx + 1 >= len(lines) or not lines[line_idx+1].strip().startswith("|"):
                    if final_lines: 
                        for k in range(len(final_lines) -1, -1, -1):
                            if final_lines[k].strip().startswith("|") and not re.match(r"\|(:---[:|-]*)+\|", final_lines[k].strip()):
                                final_lines.pop(k) 
                                break 
                    continue 
            final_lines.append(line)
            last_line_blank = False
        elif not last_line_blank: 
            final_lines.append("")
            last_line_blank = True
            
    while final_lines and final_lines[-1].strip() == "":
        final_lines.pop()

    output = "\n".join(final_lines)
    if output and not output.endswith("\n"): 
        output += "\n"
    return output

if __name__ == "__main__":
    file_path = "HBM_to_JPA_Mapping_Guide.md"
    with open(file_path, "r", encoding="utf-8") as f:
        content = f.read()
    
    modified_content = remove_unimplemented_features_master(content)
    
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(modified_content)
    
    print(f"Successfully performed targeted HBM <element> and @ElementCollection cleanup in {file_path}")
